<!DOCTYPE html>
<html lang="ro">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="favicon.png" />
    <title>PIPP A1S1</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&display=swap");

      :root {
        --bg: #0d1117;
        --card: #111827;
        --text: #e6edf3;
        --muted: #9aa5b1;
        --shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
        --fph: #ffb3b3;
        --fph-2: #f16c6c;
        --fped: #ffd6a1;
        --fped-2: #f3a742;
        --pdezv: #d6f5b2;
        --pdezv-2: #87c148;
        --phed: #ffc5e6;
        --phed-2: #ef7abf;
        --pedcom: #d4c7ff;
        --pedcom-2: #8d7cf5;
        --lr: #b0e1ff;
        --lr-2: #5ca6ff;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        min-height: 100vh;
        background: radial-gradient(
            circle at 20% 20%,
            rgba(255, 183, 3, 0.08),
            transparent 35%
          ),
          radial-gradient(
            circle at 80% 0%,
            rgba(100, 255, 218, 0.12),
            transparent 30%
          ),
          var(--bg);
        font-family: "Manrope", "Space Grotesk", "Helvetica Neue", Arial,
          sans-serif;
        color: var(--text);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 32px 18px;
      }

      .shell {
        width: min(1080px, 96vw);
        position: relative;
        overflow: hidden;
      }

      .intro {
        background: linear-gradient(
          135deg,
          rgba(255, 183, 3, 0.18),
          rgba(100, 255, 218, 0.22)
        );
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 20px;
        padding: 34px 36px;
        box-shadow: var(--shadow);
        text-align: center;
        transform-origin: center;
        transition: transform 0.7s ease, opacity 0.7s ease;
        position: relative;
        z-index: 2;
      }

      .intro h1 {
        font-size: 2.5rem;
        letter-spacing: -0.03em;
        margin-bottom: 12px;
      }

      .intro p {
        color: var(--muted);
        font-size: 1rem;
        margin-bottom: 20px;
      }

      .start-btn {
        background: #000;
        color: #fff;
        border: none;
        padding: 14px 22px;
        border-radius: 999px;
        font-size: 1rem;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.25);
        transition: transform 0.25s ease, box-shadow 0.25s ease;
      }

      .start-btn:hover {
        transform: translateY(-2px) scale(1.02);
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.32);
      }
      .start-btn:active {
        transform: translateY(0) scale(0.99);
      }

      .map {
        margin-top: 26px;
        background: var(--card);
        border: 1px solid rgba(255, 255, 255, 0.04);
        border-radius: 20px;
        padding: 26px;
        box-shadow: var(--shadow);
        transform: scale(1);
        opacity: 1;
        transition: transform 0.7s ease, opacity 0.7s ease;
        position: relative;
        z-index: 1;
      }

      .map.visible {
        transform: scale(1);
        opacity: 1;
      }
      .intro.hidden {
        transform: scale(0.9);
        opacity: 0;
      }

      .map h2 {
        font-size: 1.4rem;
        margin-bottom: 18px;
        color: #ffffff;
        letter-spacing: -0.02em;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 16px;
      }

      @media (min-width: 1120px) {
        .grid {
          grid-template-columns: repeat(3, minmax(0, 1fr));
        }
      }

      @keyframes shinePulse {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.18),
            0 10px 28px rgba(0, 0, 0, 0.28);
          filter: brightness(1);
        }
        50% {
          box-shadow: 0 0 0 8px rgba(255, 255, 255, 0.04),
            0 14px 32px rgba(0, 0, 0, 0.32);
          filter: brightness(1.05);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 255, 255, 0),
            0 10px 28px rgba(0, 0, 0, 0.28);
          filter: brightness(1);
        }
      }

      .deck-card.fade-out {
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 0.28s ease, transform 0.28s ease;
      }

      .deck-card.fade-in-card {
        opacity: 0;
        transform: translateY(8px);
      }

      .deck-card.fade-in-card.fade-in-card-active {
        opacity: 1;
        transform: translateY(0);
        transition: opacity 0.28s ease, transform 0.28s ease;
      }

      @media (max-width: 1119px) {
        .grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      @media (max-width: 768px) {
        .flip-shell {
          min-height: 600px !important;
        }

        .deck-header {
          padding: 12px !important;
        }

        .deck-score-pill {
          padding: 6px 12px !important;
        }
      }

      @media (max-width: 786px) {
        .grid {
          grid-template-columns: repeat(1, minmax(0, 1fr));
        }
      }

      .card.locked {
        position: relative;
        opacity: 0.75;
        filter: saturate(0.55);
        pointer-events: none;
        border: none !important;
      }

      .card.locked .lock-overlay {
        position: absolute;
        inset: 0;
        background: radial-gradient(
            circle at 40% 35%,
            rgba(255, 255, 255, 0.16),
            rgba(255, 255, 255, 0)
          ),
          rgba(8, 12, 22, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        color: #e2e8f0;
        font-weight: 800;
        letter-spacing: 0.01em;
        border-radius: 16px;
        z-index: 2;
      }

      .lock-overlay .lock-icon {
        width: 64px;
        height: 64px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.16);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.18),
          0 10px 22px rgba(0, 0, 0, 0.22);
        animation: lockPulse 3.8s ease-in-out infinite;
      }

      .lock-overlay .lock-icon svg {
        width: 28px;
        height: 28px;
      }

      @keyframes lockPulse {
        0% {
          transform: scale(1);
          box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.18),
            0 10px 22px rgba(0, 0, 0, 0.22);
        }
        50% {
          transform: scale(1.08);
          box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2),
            0 14px 28px rgba(0, 0, 0, 0.26);
        }
        100% {
          transform: scale(1);
          box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.18),
            0 10px 22px rgba(0, 0, 0, 0.22);
        }
      }

      .card {
        border-radius: 18px;
        padding: 16px 18px;
        color: #0b0d10;
        position: relative;
        overflow: hidden;
        cursor: pointer;
        transition: transform 0.25s ease, box-shadow 0.25s ease;
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.26),
          inset 0 1px 0 rgba(255, 255, 255, 0.18);
      }

      .card:hover {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.24);
      }
      .card.zoomed {
        transform: scale(1.05);
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.28);
      }

      .card-header {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 12px;
        align-items: center;
        margin-bottom: 6px;
      }

      .card h3 {
        font-size: 1.764rem;
        margin-bottom: 4px;
        font-weight: 800;
        line-height: 1.2;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        opacity: 0.8;
      }

      @media (min-width: 900px) {
        .modal h3 {
          font-size: 1.625rem;
        }
      }

      .card .icon-stack {
        display: grid;
        justify-items: center;
        gap: 6px;
      }

      .card .icon {
        width: 96px;
        height: 96px;
        aspect-ratio: 1 / 1;
        border-radius: 50%;
        position: relative;
        background-color: #fff;
        background-image: var(--icon-bg, none),
          radial-gradient(
            circle at 30% 28%,
            rgba(255, 255, 255, 0.98),
            rgba(255, 255, 255, 0.72)
          ),
          radial-gradient(
            circle at 70% 70%,
            rgba(0, 0, 0, 0.06),
            rgba(0, 0, 0, 0)
          );
        background-size: 68%, 100%, 100%;
        background-position: center, center, center;
        background-repeat: no-repeat;
        display: grid;
        place-items: center;
        font-size: 0;
        color: transparent;
        flex-shrink: 0;
        box-shadow: inset 0 6px 14px rgba(255, 255, 255, 0.8),
          inset 0 -10px 16px rgba(0, 0, 0, 0.08), 0 12px 32px rgba(0, 0, 0, 0.2),
          0 0 0 2px rgba(255, 255, 255, 0.7);
      }

      .card .icon::after {
        content: "";
        position: absolute;
        inset: 10%;
        border-radius: 50%;
        background: radial-gradient(
          circle at 30% 30%,
          rgba(255, 255, 255, 0.7),
          rgba(255, 255, 255, 0)
        );
        pointer-events: none;
        filter: blur(1px);
      }

      .card .abbr {
        font-weight: 800;
        font-size: 1.15rem;
        color: rgba(0, 0, 0, 0.65);
        letter-spacing: 0.04em;
        opacity: 0.5;
      }

      .card .desc {
        display: none;
      }

      .progress {
        margin-top: 10px;
        background: rgba(0, 0, 0, 0.24);
        border-radius: 14px;
        height: 22px;
        overflow: hidden;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
        position: relative;
      }

      .progress-bar {
        height: 100%;
        border-radius: inherit;
        width: 0%;
        position: relative;
        overflow: hidden;
        isolation: isolate;
        background: var(--bar-base, #b32d2d);
        box-shadow: 0 0 12px var(--bar-glow, rgba(239, 107, 107, 0.8));
        background-image: linear-gradient(
            135deg,
            rgba(255, 255, 255, 0.18),
            rgba(255, 255, 255, 0.08)
          ),
          repeating-linear-gradient(
            45deg,
            rgba(255, 255, 255, 0.16) 0,
            rgba(255, 255, 255, 0.16) 12px,
            transparent 12px,
            transparent 24px
          );
        background-size: auto, 28px 28px;
        animation: stripeMove 2.25s linear infinite;
      }

      .progress-value {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding-right: 10px;
        font-weight: 800;
        font-size: 0.9rem;
        color: #f8fbff;
        text-shadow: 0 1px 4px rgba(0, 0, 0, 0.35);
        pointer-events: none;
      }

      .progress-label {
        display: none;
      }

      .progress-inline {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 6px;
      }

      .card::before {
        content: "";
        position: absolute;
        inset: -30% 30% 60% -40%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.25),
          transparent 55%
        );
        opacity: 0.6;
        transform: rotate(8deg);
        pointer-events: none;
      }

      .card.fph {
        background: linear-gradient(
          145deg,
          rgba(255, 179, 179, 0.95),
          rgba(241, 108, 108, 0.95)
        );
        border: 1px solid rgba(241, 108, 108, 0.45);
      }
      .card.fped {
        background: linear-gradient(
          145deg,
          rgba(255, 214, 161, 0.92),
          rgba(243, 167, 66, 0.94)
        );
        border: 1px solid rgba(243, 167, 66, 0.4);
      }
      .card.pdezv {
        background: linear-gradient(
          145deg,
          rgba(214, 245, 178, 0.95),
          rgba(135, 193, 72, 0.94)
        );
        border: 1px solid rgba(135, 193, 72, 0.45);
      }
      .card.phed {
        background: linear-gradient(
          145deg,
          rgba(255, 197, 230, 0.92),
          rgba(239, 122, 191, 0.94)
        );
        border: 1px solid rgba(239, 122, 191, 0.35);
      }
      .card.pedcom {
        background: linear-gradient(
          145deg,
          rgba(212, 199, 255, 0.95),
          rgba(141, 124, 245, 0.96)
        );
        border: 1px solid rgba(141, 124, 245, 0.4);
      }
      .card.lr {
        background: linear-gradient(
          145deg,
          rgba(176, 225, 255, 0.92),
          rgba(92, 166, 255, 0.96)
        );
        border: 1px solid rgba(92, 166, 255, 0.38);
      }

      .card.fph .progress-bar {
        --bar-base: #b32d2d;
        --bar-glow: rgba(239, 107, 107, 1);
      }
      .card.fph h3 {
        color: #6d1616;
      }
      .card.fped .progress-bar {
        --bar-base: #a85b00;
        --bar-glow: rgba(226, 141, 26, 1);
      }
      .card.fped h3 {
        color: #6b3a00;
      }
      .card.pdezv .progress-bar {
        --bar-base: #588524;
        --bar-glow: rgba(152, 208, 79, 1);
      }
      .card.pdezv h3 {
        color: #355114;
      }
      .card.phed .progress-bar {
        --bar-base: #b02672;
        --bar-glow: rgba(223, 95, 168, 1);
      }
      .card.phed h3 {
        color: #6f1847;
      }
      .card.pedcom .progress-bar {
        --bar-base: #4636ad;
        --bar-glow: rgba(123, 107, 240, 1);
      }
      .card.pedcom h3 {
        color: #2e2474;
      }
      .card.lr .progress-bar {
        --bar-base: #1e65c5;
        --bar-glow: rgba(77, 141, 240, 1);
      }
      .card.lr h3 {
        color: #15417c;
      }

      /* Subject icons (inline svg as data URI) */
      .icon-brain {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%23f26a6a' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M52 22c-11 0-20 9-20 20v4c-8 2-14 10-14 18 0 11 9 20 20 20h7v8c0 10 8 18 18 18s18-8 18-18v-8h7c11 0 20-9 20-20 0-8-6-16-14-18v-4c0-11-9-20-20-20-4 0-8 1-12 3-4-2-8-3-12-3z'/><path d='M60 30v60'/><path d='M46 40c-5 3-8 8-8 14s3 11 8 14'/><path d='M74 40c5 3 8 8 8 14s-3 11-8 14'/><path d='M48 54c-3 2-5 5-5 8s2 6 5 8'/><path d='M72 54c3 2 5 5 5 8s-2 6-5 8'/></svg>");
        background-size: 66% !important;
        background-position: center center !important;
      }
      .icon-cap {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%23d63d8c' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M12 44l48-16 48 16-48 16-48-16z'/><path d='M36 54v18c0 9 11 16 24 16s24-7 24-16V54' stroke-width='7'/><path d='M96 52v18' stroke-width='7'/><circle cx='96' cy='78' r='6' fill='%23d63d8c'/></svg>");
      }
      .icon-plant {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%2387c148' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M60 98V54'/><path d='M60 70c-18 0-32-12-32-28 12 0 21 4 32 12 11-8 20-12 32-12 0 16-14 28-32 28z'/><path d='M60 54c-10 0-18-8-18-18 8 0 12 2 18 6 6-4 10-6 18-6 0 10-8 18-18 18z'/></svg>");
      }
      .icon-stack {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%23c58a2a' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M20 34l32-10 48 14-32 10-48-14z'/><path d='M20 54l32-10 48 14-32 10-48-14z'/><path d='M20 74l32-10 48 14-32 10-48-14z'/></svg>");
      }
      .icon-book {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%2347a2ff' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M60 30v60'/><path d='M60 30c-10-6-22-8-34-6v60c12-2 24 0 34 6'/><path d='M60 30c10-6 22-8 34-6v60c-12-2-24 0-34 6'/></svg>");
      }
      .icon-bubble {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%237b6bf0' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M60 24c-22 0-40 14-40 32 0 18 18 32 40 32 4 0 8-0 12-1l18 9-4-14c9-6 14-15 14-26 0-18-18-32-40-32z'/></svg>");
      }

      .card .progress-bar {
        filter: saturate(1.35) brightness(1.1);
        box-shadow: 0 0 20px var(--bar-glow, rgba(239, 107, 107, 0.9));
        background-image: linear-gradient(
            135deg,
            rgba(255, 255, 255, 0.26),
            rgba(255, 255, 255, 0.12)
          ),
          repeating-linear-gradient(
            45deg,
            rgba(255, 255, 255, 0.22) 0,
            rgba(255, 255, 255, 0.22) 12px,
            transparent 12px,
            transparent 24px
          );
      }

      @keyframes bubble {
        0% {
          transform: translateX(-12%) translateY(6%) scale(1);
        }
        50% {
          transform: translateX(12%) translateY(-6%) scale(1.1);
        }
        100% {
          transform: translateX(-12%) translateY(6%) scale(1);
        }
      }

      @keyframes bubbleReverse {
        0% {
          transform: translateX(10%) translateY(-4%) scale(1);
        }
        50% {
          transform: translateX(-10%) translateY(4%) scale(1.08);
        }
        100% {
          transform: translateX(10%) translateY(-4%) scale(1);
        }
      }

      @keyframes stripeMove {
        from {
          background-position: 0 0, 0 0;
        }
        to {
          background-position: 0 0, 56px 0;
        }
      }

      @keyframes modalLift {
        0% {
          transform: translateY(12px) scale(0.96) rotate(-0.18deg);
          opacity: 0;
          box-shadow: 0 14px 40px rgba(0, 0, 0, 0.25);
        }
        60% {
          transform: translateY(-4px) scale(1.01) rotate(0deg);
          opacity: 1;
          box-shadow: 0 22px 58px rgba(0, 0, 0, 0.3);
        }
        100% {
          transform: translateY(0) scale(1) rotate(0deg);
          opacity: 1;
          box-shadow: var(--shadow);
        }
      }

      @keyframes modalClose {
        0% {
          transform: translateY(0) scale(1) rotate(0deg);
          opacity: 1;
          box-shadow: var(--shadow);
        }
        100% {
          transform: translateY(10px) scale(0.95) rotate(-0.1deg);
          opacity: 0;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
      }

      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
        z-index: 10;
      }

      .overlay.show {
        display: flex;
      }

      .modal {
        background: #0f172a;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 20px;
        padding: 22px;
        width: min(950px, 100%);
        box-shadow: var(--shadow);
        color: var(--text);
        position: relative;
        max-height: 92vh;
        overflow-y: auto;
        scroll-behavior: smooth;
        transform: translateY(12px) scale(0.96) rotate(-0.1deg);
        opacity: 0;
        will-change: transform, opacity;
      }

      .overlay.show .modal {
        animation: modalLift 0.55s cubic-bezier(0.22, 1, 0.36, 1);
        transform: translateY(0) scale(1) rotate(0deg);
        opacity: 1;
      }

      .modal.closing {
        animation: modalClose 0.32s cubic-bezier(0.33, 1, 0.68, 1) forwards;
      }

      .modal h3 {
        font-size: 1.3rem;
        margin-bottom: 6px;
      }
      .modal p {
        color: var(--muted);
        margin-bottom: 8px;
      }
      .modal .close {
        position: absolute;
        top: 12px;
        right: 12px;
        background: rgba(255, 255, 255, 0.08);
        border: none;
        color: #fff;
        border-radius: 50%;
        width: 34px;
        height: 34px;
        font-size: 1rem;
        cursor: pointer;
      }

      .topic {
        padding: 16px 14px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.04);
        margin-bottom: 12px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
        width: 100%;
      }

      .topic strong {
        color: #fff;
        display: block;
      }
      .topic .meta {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .topic .progress {
        margin: 6px 0 0 0;
        height: 22px;
      }

      .pill {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 10px 14px;
        font-size: 0.98rem;
        color: #fff;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        justify-content: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.18);
      }

      .pill-course {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 10px;
        padding: 16px 16px;
        width: 100%;
        margin-right: 6px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2),
          0 12px 28px rgba(0, 0, 0, 0.25);
      }

      .pill-course .pill-percent {
        padding: 6px 10px;
        border-radius: 12px;
        font-weight: 800;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2),
          0 0 12px rgba(255, 255, 255, 0.18);
        border: 1px solid rgba(255, 255, 255, 0.28);
      }

      .pill-percent.red {
        background: linear-gradient(
          120deg,
          rgba(248, 113, 113, 0.22),
          rgba(248, 113, 113, 0.32)
        );
        color: #fee2e2;
      }
      .pill-percent.orange {
        background: linear-gradient(
          120deg,
          rgba(251, 146, 60, 0.22),
          rgba(251, 146, 60, 0.32)
        );
        color: #fff7ed;
      }
      .pill-percent.yellow {
        background: linear-gradient(
          120deg,
          rgba(250, 204, 21, 0.22),
          rgba(250, 204, 21, 0.32)
        );
        color: #fefce8;
      }
      .pill-percent.green {
        background: linear-gradient(
          120deg,
          rgba(52, 211, 153, 0.22),
          rgba(52, 211, 153, 0.32)
        );
        color: #ecfdf3;
      }

      .pill-percent {
        color: #fff;
      }

      .quiz-btn,
      .pdf-link {
        background: linear-gradient(135deg, #f8fafc, #e2e8f0);
        color: #0f172a;
        border: 1px solid rgba(15, 23, 42, 0.08);
        padding: 12px 16px;
        border-radius: 14px;
        font-weight: 800;
        letter-spacing: 0.01em;
        cursor: pointer;
        transition: transform 0.18s ease, box-shadow 0.18s ease,
          filter 0.18s ease;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.24),
          inset 0 1px 0 rgba(255, 255, 255, 0.6);
        text-transform: uppercase;
      }

      .quiz-btn:hover,
      .pdf-link:hover {
        transform: translateY(-1px) scale(1.01);
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.26);
        filter: brightness(1.02);
      }
      .quiz-btn:active,
      .pdf-link:active {
        transform: translateY(0);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.2);
      }

      .quiz {
        margin-top: 14px;
        padding: 16px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.07);
      }

      .quiz-question {
        position: relative;
        padding-left: 46px;
      }

      .quiz h4 {
        margin-top: 12px;
        margin-bottom: 16px;
        font-size: 1.2rem;
        line-height: 1.6;
      }
      .quiz label {
        display: block;
        margin-bottom: 8px;
        cursor: pointer;
      }
      .quiz input {
        margin-right: 10px;
        width: 20px;
        height: 20px;
        vertical-align: middle;
      }

      .choice {
        padding: 8px 10px;
        border-radius: 10px;
        transition: background 0.2s ease, transform 0.2s ease;
        display: flex;
        align-items: center;
        gap: 10px;
        line-height: 30px;
      }

      .choice:hover {
        background: rgba(255, 255, 255, 0.04);
        transform: translateX(2px);
      }

      .choice.correct {
        background: rgba(34, 197, 94, 0.18);
        border: 1px solid rgba(34, 197, 94, 0.4);
      }

      .choice.incorrect {
        background: rgba(239, 68, 68, 0.16);
        border: 1px solid rgba(239, 68, 68, 0.3);
      }

      .quiz-sep {
        border: none;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        margin: 32px 0;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.12);
      }

      .quiz-question::before {
        content: "?";
        position: absolute;
        left: 0;
        top: -4px;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.12);
        color: #d1d5db;
        display: grid;
        place-items: center;
        font-weight: 800;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.25);
      }

      .quiz-question.q-correct::before {
        content: "‚úì";
        background: rgba(16, 185, 129, 0.22);
        color: #34d399;
        border: 1px solid rgba(52, 211, 153, 0.6);
      }

      .quiz-question.q-incorrect::before {
        content: "‚úï";
        background: rgba(239, 68, 68, 0.18);
        color: #f87171;
        border: 1px solid rgba(248, 113, 113, 0.6);
      }

      .toggle-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 12px 18px;
        border-radius: 999px;
        text-transform: uppercase;
        font-weight: 900;
        letter-spacing: 0.04em;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.95),
          rgba(255, 255, 255, 0.82)
        );
        color: #0f172a;
        border: 1px solid rgba(15, 23, 42, 0.08);
        box-shadow: 0 12px 28px rgba(0, 0, 0, 0.22),
          inset 0 1px 0 rgba(255, 255, 255, 0.7);
      }

      .chevron {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.15rem;
        font-weight: 900;
        line-height: 1;
        transition: transform 0.3s ease;
        transform-origin: 50% 50%;
        width: 18px;
        height: 18px;
        text-align: center;
      }

      .collapsible {
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transform: translateY(-6px);
        transition: max-height 0.35s ease, opacity 0.35s ease,
          transform 0.35s ease;
        pointer-events: none;
      }

      .collapsible.expanded {
        max-height: none;
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
        margin-top: 6px;
        overflow: visible;
      }

      #quizPanel {
        transform: scale(0.97);
        opacity: 0;
        transition: transform 0.35s ease, opacity 0.35s ease;
      }

      #quizPanel.show {
        transform: scale(1);
        opacity: 1;
      }

      #quizPanel.exit {
        transform: scale(0.95);
        opacity: 0;
      }

      #quizPanel.complete {
        animation: quizCelebrate 0.65s ease;
      }

      .confetti {
        position: absolute;
        width: 8px;
        height: 12px;
        background: #ffb703;
        opacity: 0.9;
        border-radius: 2px;
        animation: confettiFall 1s ease-out forwards;
        pointer-events: none;
      }

      @keyframes quizCelebrate {
        0% {
          transform: scale(0.97);
          opacity: 0.6;
        }
        50% {
          transform: scale(1.05);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes confettiFall {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(140px) rotate(240deg);
          opacity: 0;
        }
      }

      .feedback {
        margin-top: 10px;
        padding: 10px 12px;
        border-radius: 10px;
        font-weight: 700;
        display: none;
      }

      .feedback.success {
        display: block;
        background: rgba(16, 185, 129, 0.15);
        color: #a7f3d0;
        border: 1px solid rgba(16, 185, 129, 0.3);
      }

      .feedback.info {
        display: block;
        background: rgba(255, 255, 255, 0.07);
        color: #e5e7eb;
        border: 1px solid rgba(255, 255, 255, 0.12);
      }

      .empty {
        padding: 14px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.04);
        color: var(--muted);
        text-align: center;
      }

      .capitol {
        padding: 16px;
        border-radius: 16px;
        background: linear-gradient(
          150deg,
          rgba(255, 255, 255, 0.04),
          rgba(13, 17, 23, 0.6)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        margin-bottom: 24px;
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      .capitol-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 12px;
        flex-wrap: wrap;
      }

      .capitol-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        flex: 0;
      }

      .subcap {
        padding: 12px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
        margin: 12px 0 0 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: stretch;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
      }

      .subcap-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        width: 100%;
      }

      .subcap-title {
        font-weight: 800;
        color: #f8fafc;
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 0;
      }

      .subcap-status {
        width: 24px;
        height: 24px;
        min-width: 24px;
        min-height: 24px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.3);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: 900;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.65);
        background: transparent;
        transition: all 0.2s ease;
        flex-shrink: 0;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
      }

      .subcap-status.done {
        background: rgba(52, 211, 153, 0.15);
        border-color: rgba(52, 211, 153, 0.8);
        color: #34d399;
        box-shadow: 0 0 12px rgba(52, 211, 153, 0.35);
      }

      .subcap-quiz-list .topic {
        position: relative;
        display: block;
        padding-right: 16px;
      }

      .subcap-quiz-list .topic button {
        position: absolute;
        right: 16px;
        top: 16px;
      }

      .subcap-quiz-list .topic .progress {
        margin-top: 12px;
        width: 100%;
      }

      .hidden {
        display: none !important;
      }

      #capitoleContainer,
      #topicsContainer {
        margin-top: 36px;
      }

      .completed-highlight {
        animation: completedPulse 1.8s ease;
      }

      .emoji-pop {
        position: absolute;
        font-size: 1.5rem;
        animation: emojiRise 0.9s ease forwards;
        pointer-events: none;
      }

      .quiz-actions {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-top: 12px;
      }

      .quiz-btn.primary {
        flex: 1;
        background: linear-gradient(135deg, #22d3ee, #4f46e5);
        color: #f8fafc;
        border: 1px solid rgba(79, 70, 229, 0.4);
        box-shadow: 0 14px 30px rgba(79, 70, 229, 0.35);
      }

      .quiz-btn.secondary {
        background: rgba(255, 255, 255, 0.08);
        color: #e6edf3;
        border: 1px solid rgba(255, 255, 255, 0.16);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
      }

      .quiz-btn.split {
        flex: 1;
        justify-content: center;
      }

      @keyframes completedPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(107, 232, 247, 0.4);
        }
        50% {
          box-shadow: 0 0 0 10px rgba(107, 232, 247, 0.1);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(107, 232, 247, 0);
        }
      }

      @keyframes emojiRise {
        0% {
          transform: translateY(10px) scale(0.85);
          opacity: 0;
        }
        60% {
          transform: translateY(-10px) scale(1.1);
          opacity: 1;
        }
        100% {
          transform: translateY(-20px) scale(1);
          opacity: 0;
        }
      }

      @media (max-width: 600px) {
        body {
          padding: 0px;
        }

        .intro h1 {
          font-size: 2rem;
        }
        .map {
          padding: 18px;
        }
        .modal {
          padding: 18px;
        }
        .capitol-header {
          flex-direction: column;
          align-items: stretch;
          gap: 10px;
          width: 100%;
        }
        .capitol-actions {
          width: 100%;
          justify-content: flex-start;
        }
        .capitol-actions .quiz-btn {
          width: 100%;
          justify-content: center;
        }
        .pill-course {
          width: 100%;
          margin-bottom: 4px;
        }
        .subcap-header {
          flex-direction: column;
          align-items: flex-start;
        }
        .subcap button {
          width: 100%;
          justify-content: center;
        }
        .subcap-quiz-list .topic {
          padding-right: 16px;
        }
        .subcap-quiz-list .topic button {
          position: static;
          width: 100%;
          margin-top: 8px;
        }

        /* Deck flashcards */
        .deck-row {
          display: flex;
          flex-wrap: wrap;
          gap: 12px;
          margin-top: 16px;
          align-items: stretch;
        }

        .deck-box {
          flex: 1 1 320px;
          position: relative;
          overflow: hidden;
        }

        .deck-box.deck-primary {
          background: rgba(255, 255, 255, 0.03);
          border: 1px solid rgba(255, 255, 255, 0.08);
          border-radius: 14px;
          padding: 14px;
          box-shadow: 0 12px 28px rgba(0, 0, 0, 0.25),
            inset 0 1px 0 rgba(255, 255, 255, 0.15);
          display: grid;
          gap: 10px;
        }

        .deck-front-area {
          display: grid;
          gap: 10px;
          justify-items: center;
        }

        .deck-term {
          font-weight: 800;
          font-size: 1.1rem;
          text-align: center;
        }

        .deck-score {
          text-align: center;
          color: #cbd5e1;
          font-weight: 700;
        }

        .deck-score-pill {
          display: inline-flex;
          align-items: center;
          gap: 6px;
          padding: 6px 12px;
          border-radius: 999px;
          background: rgba(255, 255, 255, 0.08);
          border: 1px solid rgba(255, 255, 255, 0.12);
          font-weight: 800;
        }

        .deck-header {
          display: flex;
          align-items: center;
          justify-content: space-between;
          gap: 10px;
        }

        .deck-title {
          font-weight: 800;
          color: #f8fafc;
          letter-spacing: 0.01em;
        }

        .deck-cards {
          display: grid;
          gap: 12px;
          padding: 0;
        }

        .deck-meta {
          display: grid;
          gap: 6px;
          justify-items: end;
        }

        .deck-card {
          background: rgba(255, 255, 255, 0.04);
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 12px;
          padding: 14px;
          display: grid;
          gap: 10px;
        }

        .deck-card.static {
          background: linear-gradient(
            145deg,
            rgba(255, 255, 255, 0.06),
            rgba(255, 255, 255, 0.02)
          );
          border: 1px solid rgba(255, 255, 255, 0.12);
          box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12),
            0 10px 24px rgba(0, 0, 0, 0.28);
        }

        .deck-card.feature {
          background: linear-gradient(
            150deg,
            rgba(255, 255, 255, 0.08),
            rgba(15, 23, 42, 0.4)
          );
          border: 1px solid rgba(255, 255, 255, 0.14);
          box-shadow: 0 18px 46px rgba(0, 0, 0, 0.35),
            inset 0 1px 0 rgba(255, 255, 255, 0.18);
          padding: 0px;
        }

        .deck-chip {
          display: inline-flex;
          align-items: center;
          gap: 6px;
          background: rgba(34, 211, 238, 0.16);
          border: 1px solid rgba(34, 211, 238, 0.4);
          color: #a5f3fc;
          border-radius: 999px;
          padding: 6px 10px;
          font-weight: 800;
          letter-spacing: 0.01em;
          width: fit-content;
        }

        .deck-front-label,
        .deck-back-label {
          font-size: 0.9rem;
          letter-spacing: 0.02em;
          text-transform: uppercase;
          color: #cbd5e1;
        }

        .deck-front {
          font-weight: 800;
          font-size: 1.05rem;
          color: #f8fafc;
        }

        .deck-back {
          color: #e6edf3;
          font-size: 0.98rem;
          line-height: 1.55;
        }

        .deck-card.completed {
          opacity: 0.85;
        }

        .deck-counts {
          margin-top: 10px;
          display: flex;
          gap: 8px;
          align-items: center;
        }

        .deck-dot {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          min-width: 36px;
          padding: 6px 10px;
          border-radius: 999px;
          font-weight: 800;
          color: #0f172a;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
        .deck-dot.red {
          background: #f87171;
          color: #1f2937;
        }
        .deck-dot.yellow {
          background: #facc15;
          color: #1f2937;
        }
        .deck-dot.green {
          background: #22c55e;
          color: #0b1a10;
        }

        /* Flip effect */
        .flip-wrap {
          perspective: 1200px;
        }
        .flip-card {
          position: relative;
          width: 100%;
          min-height: 200px;
          transform-style: preserve-3d;
          transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
        }
        .flip-face {
          position: absolute;
          inset: 0;
          backface-visibility: hidden;
        }
        .flip-back {
          transform: rotateY(180deg);
        }
        .deck-box.revealed .flip-card {
          transform: rotateY(180deg);
        }

        .quiz-question {
          padding-left: 0;
          padding-top: 10px;
        }

        .quiz-question::before {
          position: relative;
          left: 0;
          top: 0;
          margin-bottom: 8px;
        }

        .modal {
          width: 100vw;
          height: 100vh;
          max-height: 100vh;
          border-radius: 0;
          padding: 18px;
        }

        .overlay {
          padding: 0;
        }
      }

      .tip {
        position: relative;
        cursor: pointer;
        color: #e6f2ff;
        text-decoration: none;
        border-bottom: none;
        padding-bottom: 4px;

        background-image: linear-gradient(to right, #315565, #2a3549);
        background-position: 0 100%;
        background-repeat: no-repeat;
        background-size: 100% 2px;
      }

      /* Desktop / tablet */
      .tip .tooltip-box {
        position: absolute;
        bottom: -180%;
        left: 50%;
        transform: translateX(-50%);
        background: #111;
        color: #fff;
        padding: 10px 12px;
        border-radius: 8px;
        width: 250px;
        max-width: 90vw;
        font-size: 0.9em;
        line-height: 1.45;
        text-align: left;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        opacity: 0;
        pointer-events: none;
        z-index: 9999;
        display: none !important;
        visibility: hidden !important;
      }

      .tooltip-floating {
        position: fixed;
        background: #111;
        color: #fff;
        padding: 10px 12px;
        border-radius: 8px;
        width: 400px;
        max-width: 90vw;
        font-size: 0.9em;
        line-height: 1.45;
        text-align: left;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        z-index: 12000;
        pointer-events: none;
      }

      /* Show tooltip on hover / tap (disabled ‚Äì handled by floating tooltip) */
      .tip:hover .tooltip-box {
        display: none !important;
        opacity: 0 !important;
        visibility: hidden !important;
      }

      /* Mobil: ecrane √Ænguste */
      @media (max-width: 768px) {
        .tip .tooltip-box {
          display: none !important;
        }

        .deck-box {
          padding: 0 !important;
          border-radius: 12px;
        }

        .deck-cards {
          padding: 0px !important;
          gap: 14px !important;
        }

        .deck-card.feature {
          padding: 12px !important;
          gap: 18px !important;
          min-height: 600px;
        }

        .deck-header {
          flex-direction: column;
          align-items: flex-start;
          width: 100%;
          gap: 8px;
        }

        .deck-header > * {
          width: 100%;
        }

        .deck-score-pill {
          justify-content: flex-start;
        }

        .flip-shell {
          min-height: 600px !important;
        }

        .flip-face {
          padding: 12px !important;
          gap: 12px !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <!--
      <section class="intro" id="intro">
        <h1>Bun venit!</h1>
        <p>
          ApasƒÉ butonul »ôi intrƒÉ pe harta celor 6 materii. Progresul porne»ôte de
          la 0%.
        </p>
        <button class="start-btn" id="startBtn">√éncepe cƒÉlƒÉtoria ‚Üó</button>
      </section>
      -->

      <section class="map visible" id="map">
        <h2>UNIVERSITATEA TRANSILVANIA, PIPP, Anul 1, Semestrul 1</h2>
        <div class="grid">
          <article class="card fph" data-id="fph">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-brain"></span>
                <span class="abbr">FPH</span>
              </div>
              <div>
                <h3>Fundamentele Psihologiei</h3>
                <p class="desc">
                  Punct de start pentru √Æn»õelegerea psihologiei.
                </p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
          <article class="card fped" data-id="fped">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-stack"></span>
                <span class="abbr">FPED</span>
              </div>
              <div>
                <h3>Fundamentele Pedagogiei</h3>
                <p class="desc">
                  Traseu despre baza pedagogiei »ôi metode didactice.
                </p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
          <article class="card pdezv" data-id="pdezv">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-plant"></span>
                <span class="abbr">PDEZV</span>
              </div>
              <div>
                <h3>Psihologia DezvoltƒÉrii</h3>
                <p class="desc">ExploreazƒÉ etapele dezvoltƒÉrii psihologice.</p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
          <article class="card phed" data-id="phed">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-cap"></span>
                <span class="abbr">PHEd</span>
              </div>
              <div>
                <h3>Psihologia Educa»õiei</h3>
                <p class="desc">Focus pe procesele psihologice din educa»õie.</p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
          <article class="card pedcom" data-id="pedcom">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-bubble"></span>
                <span class="abbr">PEDCOM</span>
              </div>
              <div>
                <h3>Pedagogia comunicƒÉrii</h3>
                <p class="desc">
                  Zone despre comunicare »ôi rela»õia profesor-elev.
                </p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
          <article class="card lr" data-id="lr">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-book"></span>
                <span class="abbr">LR</span>
              </div>
              <div>
                <h3>Limba Rom√¢nƒÉ</h3>
                <p class="desc">
                  ExplorƒÉri de text, gramaticƒÉ »ôi analizƒÉ literarƒÉ.
                </p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
        </div>
      </section>
    </div>

    <div class="overlay" id="detailOverlay">
      <div class="modal">
        <button class="close" id="closeDetail">√ó</button>
        <h3 id="detailTitle"></h3>
        <p id="detailDesc" class="hidden"></p>
        <div
          class="progress-inline hidden"
          id="subjectProgressWrap"
          style="margin: 12px 0 16px 0"
        >
          <div class="progress" style="flex: 1; margin-top: 0">
            <div class="progress-bar" id="subjectProgressBar"></div>
          </div>
          <div class="progress-label" id="subjectProgress">Parcurs 0%</div>
          <a
            class="pdf-link"
            id="pdfLink"
            href="#"
            target="_blank"
            rel="noreferrer"
            >Deschide PDF</a
          >
          <a class="pdf-link hidden" id="backToList" href="javascript:void(0)"
            >‚Üê √énapoi</a
          >
        </div>
        <div id="capitoleContainer"></div>
        <div id="topicsContainer" class="hidden"></div>
        <div id="quizPanel" class="hidden">
          <h4 id="quizPanelTitle" style="margin-bottom: 10px"></h4>
          <div class="quiz" id="quizPanelContent"></div>
          <div id="quizPanelFeedback" class="feedback"></div>
          <div class="quiz-actions">
            <button class="quiz-btn secondary" id="quizPanelBack" type="button">
              ‚Üê √énapoi
            </button>
            <button class="quiz-btn primary" id="quizPanelSubmit">
              Trimite rƒÉspunsul
            </button>
            <button
              class="quiz-btn secondary hidden"
              id="quizPanelRestart"
              type="button"
            >
              Reia QUIZul
            </button>
          </div>
        </div>
      </div>
    </div>

    <script src="fph.js"></script>
    <script src="phed.js"></script>
    <script>
      const subjects = [
        {
          id: "fph",
          name: "FPH (Fundamentele Psihologiei)",
          symbol: "üß†",
          pdf: "docs/fph.pdf",
          capitole: [],
          topics: [],
        },
        {
          id: "fped",
          name: "FPED (Fundamentele Pedagogiei)",
          symbol: "üìö",
          pdf: "docs/fped.pdf",
          topics: [
            {
              id: "fped-t1",
              title: "Modele de √ÆnvƒÉ»õare",
              question: {
                text: "√énvƒÉ»õarea prin descoperire pune accent pe:",
                options: [
                  "Memorare mecanicƒÉ",
                  "Explorare »ôi experimentare",
                  "Exerci»õii repetitive",
                ],
                answer: 1,
              },
            },
            {
              id: "fped-t2",
              title: "Evaluare formativƒÉ",
              question: {
                text: "Evaluarea formativƒÉ urmƒÉre»ôte:",
                options: [
                  "Clasarea studen»õilor",
                  "√émbunƒÉtƒÉ»õirea continuƒÉ a √ÆnvƒÉ»õƒÉrii",
                  "Stabilirea unei note finale",
                ],
                answer: 1,
              },
            },
          ],
        },
        {
          id: "pdezv",
          name: "PDEZV (Psihologia DezvoltƒÉrii)",
          symbol: "üå±",
          pdf: "docs/pdezv.pdf",
          topics: [
            {
              id: "pdezv-t1",
              title: "Etape de dezvoltare",
              question: {
                text: "O etapƒÉ centralƒÉ la Piaget este:",
                options: [
                  "Opera»õiilor formale",
                  "Motiva»õiei extrinseci",
                  "√énvƒÉ»õƒÉrii sociale",
                ],
                answer: 0,
              },
            },
            {
              id: "pdezv-t2",
              title: "Ata»ôament",
              question: {
                text: "Stilul de ata»ôament securizant se caracterizeazƒÉ prin:",
                options: [
                  "Evitarea constantƒÉ a adultului",
                  "Confort la √Æntoarcerea adultului",
                  "Indiferen»õƒÉ totalƒÉ",
                ],
                answer: 1,
              },
            },
          ],
        },
        {
          id: "phed",
          name: "PHEd (Psihologia Educa»õiei)",
          symbol: "üéì",
          pdf: "docs/phed.pdf",
          capitole: [],
          topics: [],
        },
        {
          id: "pedcom",
          name: "PedCom (Pedagogia comunicƒÉrii)",
          symbol: "üí¨",
          pdf: "docs/pedcom.pdf",
          topics: [
            {
              id: "pedcom-t1",
              title: "Ascultare activƒÉ",
              question: {
                text: "Ascultarea activƒÉ presupune:",
                options: [
                  "Doar auzirea mesajului",
                  "Parafrazare »ôi clarificare",
                  "Interven»õii permanente",
                ],
                answer: 1,
              },
            },
            {
              id: "pedcom-t2",
              title: "Feedback eficient",
              question: {
                text: "Feedback-ul constructiv este de obicei:",
                options: [
                  "Specific »ôi orientat spre solu»õie",
                  "General »ôi ambiguu",
                  "√éntotdeauna negativ",
                ],
                answer: 0,
              },
            },
          ],
        },
        {
          id: "lr",
          name: "Limba Rom√¢nƒÉ",
          symbol: "üìñ",
          pdf: "docs/lr.pdf",
          topics: [
            {
              id: "lr-t1",
              title: "AnalizƒÉ de text",
              question: {
                text: "O analizƒÉ literarƒÉ riguroasƒÉ include:",
                options: [
                  "Doar rezumatul textului",
                  "TemƒÉ, motive, structurƒÉ »ôi limbaj",
                  "Ignorarea contextului autorului",
                ],
                answer: 1,
              },
            },
            {
              id: "lr-t2",
              title: "GramaticƒÉ",
              question: {
                text: "Alege varianta corectƒÉ:",
                options: [
                  "Sunt sigur cƒÉ voi reu»ôi",
                  "Sunt sigur cƒÉ voi reu»ôi-voi",
                  "Sigur sunt cƒÉ voi reu»ôi",
                ],
                answer: 0,
              },
            },
          ],
        },
      ];

      const startBtn = document.getElementById("startBtn");
      const intro = document.getElementById("intro");
      const map = document.getElementById("map");
      const cards = document.querySelectorAll(".card");
      const detailOverlay = document.getElementById("detailOverlay");
      const closeDetail = document.getElementById("closeDetail");
      const detailTitle = document.getElementById("detailTitle");
      const detailDesc = document.getElementById("detailDesc");
      const pdfLink = document.getElementById("pdfLink");
      const topicsContainer = document.getElementById("topicsContainer");
      const capitoleContainer = document.getElementById("capitoleContainer");
      const subjectProgressLabel = document.getElementById("subjectProgress");
      const subjectProgressBar = document.getElementById("subjectProgressBar");
      const backToList = document.getElementById("backToList");
      const subjectProgressWrap = document.getElementById(
        "subjectProgressWrap"
      );
      const quizPanel = document.getElementById("quizPanel");
      const quizPanelTitle = document.getElementById("quizPanelTitle");
      const quizPanelContent = document.getElementById("quizPanelContent");
      const quizPanelFeedback = document.getElementById("quizPanelFeedback");
      const quizPanelSubmit = document.getElementById("quizPanelSubmit");
      const quizPanelRestart = document.getElementById("quizPanelRestart");
      const quizPanelBack = document.getElementById("quizPanelBack");

      let progressStore = loadProgress();
      let deckState = loadDeckState();

      function loadDeckState() {
        try {
          return JSON.parse(localStorage.getItem("deckStateV1")) || {};
        } catch (e) {
          return {};
        }
      }

      function saveDeckState() {
        localStorage.setItem("deckStateV1", JSON.stringify(deckState));
      }

      function getDeckCards(deck) {
        return deck?.cards ? deck.cards : [];
      }

      function splitBackContent(card) {
        const raw =
          typeof card.back === "string"
            ? card.back
            : card.back?.academic || card.back?.simple || "";
        const simpleRaw =
          typeof card.simple === "string" ? card.simple : card.back?.simple;
        let academic = raw;
        let simplified = simpleRaw || "";
        const marker = "üß†";
        if (!simplified && raw.includes(marker)) {
          const parts = raw.split(marker);
          academic = parts.shift()?.trim() || "";
          simplified = `${marker} ${parts.join(marker).trim()}`;
        }
        return {
          academic: academic || "Con»õinut indisponibil",
          simplified: simplified || "",
        };
      }

      function parseFrontParts(card) {
        const text = (card?.front || "").trim();
        const regex = /(Define»ôte|Defineste)/i;
        const m = text.match(regex);
        if (!m) {
          return {
            context: "",
            main: text || "√én cur√¢nd",
            backTitle: text || "RƒÉspuns",
          };
        }
        const idx = m.index ?? 0;
        const context = text.slice(0, idx).trim();
        const main = text.slice(idx).trim();
        const backTitle = main
          .replace(/(Define»ôte|Defineste)/i, "Defini»õie")
          .trim();
        return {
          context,
          main: main || text || "√én cur√¢nd",
          backTitle: backTitle || "RƒÉspuns",
        };
      }

      function ensureDeckState(deck) {
        const cards = getDeckCards(deck);
        const total = cards.length;
        if (!deck || !cards.length) return { idx: 0, statuses: [] };
        const st = deckState[deck.id] || { idx: 0, statuses: [] };
        if (!Array.isArray(st.statuses) || st.statuses.length !== total) {
          st.statuses = Array(total).fill("red");
        }
        if (st.idx >= total) st.idx = 0;
        deckState[deck.id] = st;
        return st;
      }

      function getSubjectDeckStats(subject) {
        if (!subject) return { count: 0, sum: 0 };
        let decks = [];
        if (subject.id === "fph" && window.FPH_FLASHCARDS) {
          decks = Object.values(window.FPH_FLASHCARDS).flat();
        }
        if (subject.id === "phed" && window.PHED_FLASHCARDS) {
          decks = Object.values(window.PHED_FLASHCARDS).flat();
        }
        let count = 0;
        let sum = 0;
        decks.forEach((deck) => {
          const cards = getDeckCards(deck);
          const st = ensureDeckState(deck);
          cards.forEach((_, idx) => {
            count += 1;
            if (st.statuses[idx] === "green") sum += 100;
          });
        });
        return { count, sum };
      }

      function getCapitolDeckStats(capitolId, subjectId = "fph") {
        const decks = getDecksForCapitol(capitolId, subjectId);
        let count = 0;
        let sum = 0;
        decks.forEach((deck) => {
          const cards = getDeckCards(deck);
          const st = ensureDeckState(deck);
          cards.forEach((_, idx) => {
            count += 1;
            if (st.statuses[idx] === "green") sum += 100;
          });
        });
        return { count, sum };
      }

      function updateCapitolPill(capitolId, subjectId = "fph") {
        const caps =
          subjectId === "phed"
            ? window.PHED_CONTENT?.capitole || []
            : window.FPH_CONTENT?.capitole || [];
        const cap = caps.find((c) => c.id === capitolId);
        if (!cap) return;
        const allTopicIds = cap.subcapitole.flatMap((s) => s.quizuri || []);
        const deckStats = getCapitolDeckStats(capitolId, subjectId);
        const quizCount = allTopicIds.length;
        const quizSum = allTopicIds.reduce(
          (sum, id) => sum + getTopicProgress(id),
          0
        );
        const quizAvg = quizCount ? quizSum / quizCount : null;
        const deckAvg = deckStats.count
          ? deckStats.sum / deckStats.count
          : null;
        let capProgress = 0;
        if (quizAvg != null && deckAvg != null) {
          capProgress = Math.round(0.5 * quizAvg + 0.5 * deckAvg);
        } else if (quizAvg != null) {
          capProgress = Math.round(quizAvg);
        } else if (deckAvg != null) {
          capProgress = Math.round(deckAvg);
        }
        const pill = capitoleContainer.querySelector(
          `[data-capitol='${capitolId}'] .pill-percent`
        );
        if (pill) {
          pill.classList.remove("red", "orange", "yellow", "green");
          pill.classList.add(pillColorClass(capProgress));
          const valEl = pill.querySelector(".pill-val");
          if (valEl) valEl.textContent = `${capProgress}%`;
          const ico = pill.querySelector(".pill-ico");
          if (ico) ico.textContent = pillIcon(capProgress);
        }
      }
      let currentTopic = null;
      let currentSubject = null;
      let currentQuizListEl = null;
      let currentQuestions = [];
      let quizCompleted = false;
      let lastCompletedTopicId = null;
      let barObserver = null;
      let floatingTooltip = null;

      // GestioneazƒÉ disponibilitatea materiilor: true = accesibil, false = blocat
      const subjectAvailability = {
        fph: true,
        fped: false,
        pdezv: false,
        phed: true,
        pedcom: false,
        lr: false,
      };

      const subjectBars = {
        fph: { base: "#b32d2d", glow: "rgba(239, 107, 107, 0.8)" },
        fped: { base: "#a85b00", glow: "rgba(226, 141, 26, 0.8)" },
        pdezv: { base: "#588524", glow: "rgba(152, 208, 79, 0.8)" },
        phed: { base: "#b02672", glow: "rgba(223, 95, 168, 0.8)" },
        pedcom: { base: "#4636ad", glow: "rgba(123, 107, 240, 0.8)" },
        lr: { base: "#1e65c5", glow: "rgba(77, 141, 240, 0.8)" },
      };

      if (startBtn) {
        startBtn.addEventListener("click", () => {
          intro.classList.add("hidden");
          map.classList.add("visible");
        });
      } else {
        map.classList.add("visible");
      }

      cards.forEach((card) => {
        card.addEventListener("click", () => {
          const subjectId = card.dataset.id;
          card.scrollIntoView({ behavior: "smooth", block: "center" });
          openDetail(subjectId);
        });
      });

      applySubjectLocks();

      closeDetail.addEventListener("click", () => closeModal(true));
      detailOverlay.addEventListener("click", (e) => {
        if (e.target === detailOverlay) closeModal(true);
      });
      quizPanelSubmit.addEventListener("click", submitQuizAnswer);
      quizPanelRestart.addEventListener("click", restartQuiz);
      quizPanelBack.addEventListener("click", goBackToSubcap);
      backToList.addEventListener("click", goBackToSubcap);

      renderCardProgress();

      function loadProgress() {
        try {
          return JSON.parse(localStorage.getItem("subjectProgressV1")) || {};
        } catch (e) {
          return {};
        }
      }

      function saveProgress() {
        localStorage.setItem(
          "subjectProgressV1",
          JSON.stringify(progressStore)
        );
      }

      function applySubjectLocks() {
        document.querySelectorAll(".card[data-id]").forEach((card) => {
          const id = card.dataset.id;
          const isOpen = subjectAvailability[id] !== false;
          if (isOpen) {
            card.classList.remove("locked");
            const overlay = card.querySelector(".lock-overlay");
            if (overlay) overlay.remove();
          } else {
            card.classList.add("locked");
            if (!card.querySelector(".lock-overlay")) {
              const layer = document.createElement("div");
              layer.className = "lock-overlay";
              layer.innerHTML = `<span class="lock-icon"><svg viewBox="0 0 24 24" fill="none" stroke="#e2e8f0" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="10" width="14" height="10" rx="2" ry="2"></rect><path d="M8 10V7a4 4 0 0 1 8 0v3"></path></svg></span>`;
              card.appendChild(layer);
            }
          }
        });
      }

      function captureFphOpenState() {
        const state = { capitolId: null, subcaps: [], decks: [] };
        const openCap = capitoleContainer.querySelector(
          ".subcap-list.expanded"
        );
        if (openCap?.id) state.capitolId = openCap.id.replace("-subs", "");
        state.subcaps = Array.from(
          capitoleContainer.querySelectorAll(".subcap-quiz-list.expanded")
        )
          .map((el) => el.dataset.quizList)
          .filter(Boolean);
        state.decks = Array.from(
          capitoleContainer.querySelectorAll(".deck-collapsible.expanded")
        )
          .map((el) => el.dataset.deckList)
          .filter(Boolean);
        return state;
      }

      function saveFphOpenState() {
        if (!currentSubject || currentSubject.id !== "fph") return;
        const state = captureFphOpenState();
        try {
          localStorage.setItem(OPEN_STATE_KEY, JSON.stringify(state));
        } catch (e) {
          /* ignore quota errors */
        }
      }

      function loadFphOpenState() {
        try {
          return JSON.parse(localStorage.getItem(OPEN_STATE_KEY)) || null;
        } catch (e) {
          return null;
        }
      }

      function restoreFphOpenState(subject) {
        if (!subject || subject.id !== "fph") return;
        const state = loadFphOpenState();
        if (!state || !state.capitolId) return;
        const capList = document.getElementById(`${state.capitolId}-subs`);
        if (capList) {
          capList.classList.add("expanded");
          const btn = capitoleContainer.querySelector(
            `[data-toggle='${state.capitolId}']`
          );
          if (btn) setChevron(btn, true);
        }
        state.subcaps.forEach((id) => {
          const el = capitoleContainer.querySelector(
            `[data-quiz-list='${id}']`
          );
          if (el) {
            el.classList.add("expanded");
            const btn = el.previousElementSibling;
            if (btn?.classList.contains("toggle-btn")) setChevron(btn, true);
            if (el.dataset.quizIds) {
              const ids = el.dataset.quizIds.split(",").filter(Boolean);
              el.innerHTML = renderInlineQuizList(subject, ids);
              wireInlineQuizButtons(el, subject);
            }
          }
        });
        state.decks.forEach((id) => {
          const deckEl = capitoleContainer.querySelector(
            `[data-deck-list='${id}']`
          );
          if (deckEl) {
            deckEl.classList.add("expanded");
            const btn = capitoleContainer.querySelector(
              `[data-deck-toggle='${id}']`
            );
            if (btn) setChevron(btn, true);
            wireDeckInteractions(deckEl);
          }
        });
      }

      function resetAllProgress() {
        progressStore = {};
        deckState = {};
        saveProgress();
        saveDeckState();
        renderCardProgress();
        lastCompletedTopicId = null;
        if (currentSubject && detailOverlay.classList.contains("show")) {
          if (currentSubject.id === "fph") {
            renderCapitole(currentSubject);
          } else {
            renderTopics(currentSubject);
          }
          applySubjectBar(currentSubject);
        }
      }

      function resetModalContent() {
        topicsContainer.innerHTML = "";
        capitoleContainer.innerHTML = "";
        cards.forEach((c) => c.classList.remove("zoomed"));
        topicsContainer.classList.add("hidden");
        capitoleContainer.classList.remove("hidden");
        quizPanel.classList.add("hidden");
        quizPanelContent.innerHTML = "";
        quizPanelFeedback.textContent = "";
        quizPanelSubmit.classList.remove("hidden");
        quizPanelRestart.classList.add("hidden");
        quizPanelBack.classList.remove("hidden");
        currentQuestions = [];
        currentTopic = null;
        currentQuizListEl = null;
        quizPanel.classList.add("hidden");
        quizPanel.classList.remove("show", "exit", "complete");
        pdfLink.classList.remove("hidden");
        backToList.classList.add("hidden");
        document.body.style.overflow = "";
      }

      function closeModal(animated = true) {
        if (!detailOverlay.classList.contains("show")) return;
        const modalEl = detailOverlay.querySelector(".modal");
        const finish = () => {
          saveFphOpenState();
          detailOverlay.classList.remove("show");
          if (modalEl) modalEl.classList.remove("closing");
          resetModalContent();
        };
        if (animated && modalEl) {
          modalEl.classList.add("closing");
          setTimeout(finish, 320);
        } else {
          finish();
        }
      }

      function getTopicProgress(topicId) {
        return progressStore[topicId] ?? 0;
      }

      function setTopicProgress(topicId, value) {
        const currentVal = progressStore[topicId] ?? 0;
        progressStore[topicId] = Math.max(currentVal, value);
        saveProgress();
        renderCardProgress();
        if (currentSubject && detailOverlay.classList.contains("show")) {
          applySubjectBar(currentSubject);
          if (currentSubject.capitole && currentSubject.capitole.length) {
            rerenderSubjectCapitolePreserveState(currentSubject);
            syncDeckHeights(capitoleContainer);
          } else if (currentQuizListEl && currentQuizListEl.dataset.quizIds) {
            const ids = currentQuizListEl.dataset.quizIds
              .split(",")
              .filter(Boolean);
            currentQuizListEl.innerHTML = renderInlineQuizList(
              currentSubject,
              ids
            );
            wireInlineQuizButtons(currentQuizListEl, currentSubject);
          }
        }
      }

      function subjectAverage(subject) {
        ensureFphData(subject);
        ensurePhedData(subject);
        const topicCount = subject.topics?.length || 0;
        const topicSum =
          subject.topics?.reduce((sum, t) => sum + getTopicProgress(t.id), 0) ||
          0;
        const topicAvg = topicCount ? topicSum / topicCount : null;

        const deckStats = getSubjectDeckStats(subject);
        const deckAvg = deckStats.count
          ? deckStats.sum / deckStats.count
          : null;

        if (topicAvg != null && deckAvg != null) {
          return Math.round(0.5 * topicAvg + 0.5 * deckAvg);
        }
        if (topicAvg != null) return Math.round(topicAvg);
        if (deckAvg != null) return Math.round(deckAvg);
        return 0;
      }

      function renderCardProgress() {
        cards.forEach((card) => {
          const subject = subjects.find((s) => s.id === card.dataset.id);
          ensureFphData(subject);
          const percent = subject ? subjectAverage(subject) : 0;
          const bar = card.querySelector(".progress-bar");
          const label = card.querySelector(".progress-label");
          if (bar) {
            bar.style.cssText = `${barStyleFor(
              subject?.id
            )} width:${percent}%;`;
            const wrap = bar.parentElement;
            if (wrap) {
              let val = wrap.querySelector(".progress-value");
              if (!val) {
                val = document.createElement("div");
                val.className = "progress-value";
                wrap.appendChild(val);
              }
              val.textContent = `${percent}%`;
            }
          }
          if (label) label.textContent = `Parcurs ${percent}%`;
        });
      }

      function openDetail(subjectId) {
        const subject = subjects.find((s) => s.id === subjectId);
        currentSubject = subject;
        if (!subject) return;
        ensurePhedData(subject);
        document.body.style.overflow = "hidden";
        ensureFphData(subject);
        detailTitle.textContent = `${subject.symbol} ${subject.name}`;
        detailDesc.textContent =
          "SelecteazƒÉ capitolele »ôi subcapitolele pentru a deschide quizurile aferente. Progresul se salveazƒÉ local.";
        detailDesc.classList.add("hidden");
        applySubjectBar(subject);
        backToList.classList.add("hidden");
        pdfLink.classList.remove("hidden");
        if (subjectProgressWrap) subjectProgressWrap.classList.add("hidden");
        pdfLink.href = subject.pdf;
        pdfLink.textContent = subject.pdf ? "Deschide PDF" : "PDF neata»ôat";
        if (subject.capitole && subject.capitole.length) {
          topicsContainer.classList.add("hidden");
          capitoleContainer.classList.remove("hidden");
          renderCapitole(subject);
          restoreFphOpenState(subject);
        } else {
          topicsContainer.classList.remove("hidden");
          capitoleContainer.classList.add("hidden");
          capitoleContainer.innerHTML = "";
          renderTopics(subject);
        }
        detailOverlay.classList.add("show");
        const modalEl = detailOverlay.querySelector(".modal");
        requestAnimationFrame(() => {
          (modalEl || detailOverlay).scrollTo({
            top: 0,
            behavior: "smooth",
          });
          window.scrollTo({ top: 0, behavior: "smooth" });
        });
      }

      function renderCapitole(subject) {
        ensureFphData(subject);
        ensurePhedData(subject);
        if (!subject.capitole || !subject.capitole.length) {
          capitoleContainer.innerHTML = `<div class="empty">Nu existƒÉ capitole definite √ÆncƒÉ.</div>`;
          return;
        }

        capitoleContainer.innerHTML = subject.capitole
          .map((capitol, idx) => {
            const allTopicIds = capitol.subcapitole.flatMap(
              (s) => s.quizuri || []
            );
            const deckStats = getCapitolDeckStats(capitol.id, subject.id);
            const quizCount = allTopicIds.length;
            const quizSum = allTopicIds.reduce(
              (sum, id) => sum + getTopicProgress(id),
              0
            );
            const quizAvg = quizCount ? quizSum / quizCount : null;
            const deckAvg = deckStats.count
              ? deckStats.sum / deckStats.count
              : null;
            const deckComplete =
              deckStats.count > 0 && deckStats.sum === deckStats.count * 100;
            let capProgress = 0;
            if (quizAvg != null && deckAvg != null) {
              capProgress = Math.round(0.5 * quizAvg + 0.5 * deckAvg);
            } else if (quizAvg != null) {
              capProgress = Math.round(quizAvg);
            } else if (deckAvg != null) {
              capProgress = Math.round(deckAvg);
            }

            return `
              <div class="capitol" data-capitol="${capitol.id}">
                  <div class="capitol-header">
                    <div style="flex:1; display:flex; align-items:center; gap:8px; min-width:0; width:100%;">
                      <div class="pill pill-course" style="background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.12); width:100%; justify-content:space-between;">
                        <span style="font-size:1.1rem;">üìë</span>
                        <span style="font-weight:800; flex:1; min-width:0;">${
                          capitol.titlu
                        }</span>
                        <span class="pill-percent ${pillColorClass(
                          capProgress
                        )}"><span class="pill-val">${capProgress}%</span> <span class="pill-ico">${pillIcon(
              capProgress
            )}</span></span>
                      </div>
                    </div>
                    <div class="capitol-actions" style="justify-content:flex-end;">
                    <button class="quiz-btn toggle-btn" data-toggle="${
                      capitol.id
                    }">
                      <span>Subcapitole</span>
                      <span class="chevron">üîΩ</span>
                    </button>
                  </div>
                  </div>
                <div class="subcap-list collapsible" id="${capitol.id}-subs">
                  ${capitol.subcapitole
                    .map((s) => {
                      const quizIds = s.quizuri || [];
                      const completedAll = quizIds.length
                        ? quizIds.every((id) => getTopicProgress(id) === 100)
                        : false;
                      return `
                      <div class="subcap">
                        <div class="subcap-header">
                          <div class="subcap-title">
                            <span class="subcap-status ${
                              completedAll ? "done" : ""
                            }">${completedAll ? "‚úì" : ""}</span>
                            <span>${s.titlu}</span>
                          </div>
                          <button class="quiz-btn toggle-btn secondary" data-quiz-ids="${quizIds.join(
                            ","
                          )}">
                            <span>QUIZURI</span>
                            <span class="chevron">üîΩ</span>
                          </button>
                        </div>
                        <div class="subcap-quiz-list collapsible" data-quiz-list="${
                          s.id
                        }" data-quiz-ids="${quizIds.join(",")}"></div>
                      </div>
                    `;
                    })
                    .join("")}
                  <div class="subcap deck-subcap" style="background:linear-gradient(135deg,rgba(120,90,200,0.14),rgba(48,40,72,0.34));border:1px solid rgba(255,255,255,0.18);border-radius:14px;padding:12px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.16), 0 12px 28px rgba(0,0,0,0.2);">
                    <div class="subcap-header" style="align-items:center;">
                      <div class="subcap-title">
                        <span class="subcap-status ${
                          deckComplete ? "done" : ""
                        }">${deckComplete ? "‚úì" : ""}</span>
                        <span>FLASHCARDS</span>
                      </div>
                      <button class="quiz-btn toggle-btn secondary deck-toggle-btn" data-deck-toggle="${
                        capitol.id
                      }" style="padding:10px 14px;border-radius:12px;background:linear-gradient(135deg,rgba(105,125,165,0.32),rgba(80,98,140,0.32));border:1px solid rgba(255,255,255,0.24);backdrop-filter:blur(6px);color:#eef2ff;box-shadow:0 8px 18px rgba(0,0,0,0.18);">
                        <span style="opacity:0.9;font-weight:800;">CARDURI</span>
                        <span class="chevron">üîΩ</span>
                      </button>
                    </div>
                    <div class="deck-collapsible collapsible" data-deck-list="${
                      capitol.id
                    }">
                      ${renderDeckRow(subject.id, capitol.id)}
                    </div>
                  </div>
                </div>
              </div>
            `;
          })
          .join("");

        capitoleContainer.querySelectorAll("[data-toggle]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const targetId = btn.dataset.toggle;
            const list = document.getElementById(`${targetId}-subs`);
            if (list) {
              const willExpand = !list.classList.contains("expanded");
              // close all other capitole
              capitoleContainer
                .querySelectorAll(".subcap-list.expanded")
                .forEach((el) => {
                  if (el !== list) {
                    el.classList.remove("expanded");
                    el.querySelectorAll(".subcap-quiz-list").forEach((s) =>
                      s.classList.remove("expanded")
                    );
                    el.querySelectorAll(".deck-collapsible").forEach((d) =>
                      d.classList.remove("expanded")
                    );
                  }
                });
              capitoleContainer
                .querySelectorAll(".capitol .chevron")
                .forEach((c) => (c.style.transform = "rotate(0deg)"));
              if (willExpand) {
                list.classList.add("expanded");
                setChevron(btn, true);
                const capEl = btn.closest(".capitol") || list;
                capEl.scrollIntoView({ behavior: "smooth", block: "start" });
              } else {
                list.classList.remove("expanded");
                setChevron(btn, false);
                // closing the capitol collapses all its subcapitole/quiz lists
                list
                  .querySelectorAll(".subcap-quiz-list")
                  .forEach((el) => el.classList.remove("expanded"));
                list
                  .querySelectorAll(".deck-collapsible")
                  .forEach((el) => el.classList.remove("expanded"));
                list
                  .querySelectorAll(".subcap .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
                list
                  .querySelectorAll(".deck-toggle-btn .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
              }
              topicsContainer.classList.add("hidden");
              quizPanel.classList.add("hidden");
            }
          });
        });

        capitoleContainer.querySelectorAll("[data-quiz-ids]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const ids = btn.dataset.quizIds.split(",").filter(Boolean);
            const quizList =
              btn.closest(".subcap")?.querySelector(".subcap-quiz-list") ||
              btn.nextElementSibling;
            if (quizList) {
              const willExpand = !quizList.classList.contains("expanded");
              // close siblings within the same capitol
              const parentCapitol = quizList.closest(".capitol");
              if (parentCapitol) {
                parentCapitol
                  .querySelectorAll(".subcap-quiz-list.expanded")
                  .forEach((el) => {
                    if (el !== quizList) el.classList.remove("expanded");
                  });
                parentCapitol
                  .querySelectorAll(".subcap .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
                parentCapitol
                  .querySelectorAll(".deck-collapsible.expanded")
                  .forEach((el) => el.classList.remove("expanded"));
                parentCapitol
                  .querySelectorAll(".deck-toggle-btn .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
              }
              if (willExpand) {
                quizList.classList.add("expanded");
                setChevron(btn, true);
              } else {
                quizList.classList.remove("expanded");
                setChevron(btn, false);
              }
              quizList.innerHTML = renderInlineQuizList(subject, ids);
              quizList.dataset.quizIds = ids.join(",");
            }
            topicsContainer.classList.add("hidden");
            wireInlineQuizButtons(quizList, subject);
          });
        });

        capitoleContainer
          .querySelectorAll("[data-deck-toggle]")
          .forEach((btn) => {
            btn.addEventListener("click", () => {
              const deckTarget = btn.dataset.deckToggle;
              const deckList = capitoleContainer.querySelector(
                `[data-deck-list='${deckTarget}']`
              );
              if (!deckList) return;
              const willExpand = !deckList.classList.contains("expanded");
              const parentCapitol = btn.closest(".capitol");
              if (parentCapitol) {
                parentCapitol
                  .querySelectorAll(".subcap-quiz-list.expanded")
                  .forEach((el) => el.classList.remove("expanded"));
                parentCapitol
                  .querySelectorAll(".deck-collapsible.expanded")
                  .forEach((el) => {
                    if (el !== deckList) el.classList.remove("expanded");
                  });
                parentCapitol
                  .querySelectorAll(".subcap .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
                parentCapitol
                  .querySelectorAll(".deck-toggle-btn .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
              }
              if (willExpand) {
                deckList.classList.add("expanded");
                setChevron(btn, true);
                scrollIntoModalView(deckList, 64);
              } else {
                deckList.classList.remove("expanded");
                setChevron(btn, false);
              }
              topicsContainer.classList.add("hidden");
              quizPanel.classList.add("hidden");
              wireDeckInteractions(deckList);
              wireTooltips(deckList);
              syncDeckHeights(deckList);
            });
          });

        wireDeckInteractions(capitoleContainer);
        wireTooltips(capitoleContainer);
        syncDeckHeights(capitoleContainer);
      }

      function renderTopics(subject, topicIds) {
        ensureFphData(subject);
        const list = topicIds
          ? subject.topics.filter((t) => topicIds.includes(t.id))
          : subject.topics;

        if (!list.length) {
          topicsContainer.innerHTML = `<div class="empty">Nu existƒÉ topicuri definite √ÆncƒÉ.</div>`;
          return;
        }

        topicsContainer.innerHTML = list
          .map((topic) => {
            const percent = getTopicProgress(topic.id);
            const barStyle = barStyleFor(subject.id);
            return `
              <div class="topic">
            <div>
              <strong>${topic.title}</strong>
              <div class="meta">RƒÉspuns corect: ${percent}%</div>
              <div class="progress">
                <div class="progress-bar" data-target="${percent}" style="width:${percent}%; ${barStyle}"></div>
                <div class="progress-value">${percent}%</div>
              </div>
            </div>
            <button class="quiz-btn" data-topic="${topic.id}">START QUIZ</button>
          </div>
        `;
          })
          .join("");

        updateBarWidths(topicsContainer, false);
        topicsContainer.querySelectorAll(".quiz-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const topicId = btn.dataset.topic;
            const topic = subject.topics.find((t) => t.id === topicId);
            openQuiz(subject, topic);
          });
        });
      }

      function renderInlineQuizList(subject, ids) {
        const list = ids.length
          ? subject.topics.filter((t) => ids.includes(t.id))
          : [];
        if (!list.length) {
          return `<div class="empty">Nu existƒÉ quizuri pentru acest subcapitol.</div>`;
        }
        return list
          .map((topic) => {
            const percent = getTopicProgress(topic.id);
            const barStyle = barStyleFor(subject.id);
            return `
            <div class="topic" data-topic-container="${topic.id}" style="margin-top:12px;">
              <div>
                <strong>${topic.title}</strong>
                <div class="meta">RƒÉspuns corect: ${percent}%</div>
                <div class="progress">
                  <div class="progress-bar" data-target="${percent}" style="width:${percent}%; ${barStyle}"></div>
                  <div class="progress-value">${percent}%</div>
                </div>
              </div>
              <button class="quiz-btn" style="padding: 10px;" data-topic="${topic.id}">START QUIZ</button>
            </div>
          `;
          })
          .join("");
      }

      function getDecksForCapitol(capitolId, subjectId = "fph") {
        if (subjectId === "phed") {
          return (
            (window.PHED_FLASHCARDS && window.PHED_FLASHCARDS[capitolId]) || []
          );
        }
        return (
          (window.FPH_FLASHCARDS && window.FPH_FLASHCARDS[capitolId]) || []
        );
      }

      function renderDeckRow(subjectId, capitolId) {
        const decks = getDecksForCapitol(capitolId, subjectId);
        if (!decks.length) return "";
        const rowStyle =
          "display:flex;flex-wrap:wrap;gap:16px;margin-top:18px;align-items:stretch;backdrop-filter:blur(4px);";
        return `<div class="deck-row" data-deck-subject="${subjectId}" data-deck-capitol="${capitolId}" style="${rowStyle}">
          ${decks
            .map((deck) => {
              const cards = getDeckCards(deck);
              const state = ensureDeckState(deck);
              const available = cards
                .map((_, i) => i)
                .filter((i) => state.statuses[i] !== "green");
              const allGreen = cards.length > 0 && available.length === 0;
              let currentIdx = state.idx || 0;
              if (!allGreen && !available.includes(currentIdx)) {
                currentIdx = available[0] || 0;
                state.idx = currentIdx;
                deckState[deck.id] = state;
              }
              const card = cards[currentIdx] || {};
              const promptParts = parseFrontParts(card);
              const backContent = splitBackContent(card);
              const redCount = state.statuses.filter((s) => s === "red").length;
              const yellowCount = state.statuses.filter(
                (s) => s === "yellow"
              ).length;
              const greenCount = state.statuses.filter(
                (s) => s === "green"
              ).length;
              const displayTitle =
                deck.title && deck.title.includes("Deck 1")
                  ? "Carduri CURS 1"
                  : deck.title || "Deck";
              const boxStyle =
                "flex:1 1 320px;position:relative;overflow:hidden;border-radius:16px;padding:28px;background:linear-gradient(145deg,rgba(255,255,255,0.06),rgba(47,29,64,0.55));border:1px solid rgba(255,255,255,0.12);box-shadow:0 18px 40px rgba(0,0,0,0.32),inset 0 1px 0 rgba(255,255,255,0.12);display:grid;gap:20px;";
              const headerStyle =
                "display:flex;align-items:center;justify-content:space-between;gap:10px;";
              const titleStyle =
                "font-weight:800;color:#f8fafc;letter-spacing:0.01em;font-size:1.02rem;";
              const pillStyle =
                "display:inline-flex;align-items:center;gap:6px;padding:6px 12px;border-radius:999px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.16);font-weight:800;color:#e2e8f0;";
              const cardsStyle = "display:grid;gap:26px;padding:18px 0;";
              const cardStyle =
                "background:linear-gradient(150deg,rgba(255,255,255,0.08),rgba(55,32,70,0.42));border:1px solid rgba(255,255,255,0.14);box-shadow:0 18px 46px rgba(0,0,0,0.35),inset 0 1px 0 rgba(255,255,255,0.18);padding:34px;border-radius:16px;position:relative;min-height:520px;max-width:760px;margin:0 auto;display:grid;gap:28px;";
              const chipStyle =
                "display:inline-flex;align-items:center;gap:6px;background:rgba(34,211,238,0.18);border:1px solid rgba(34,211,238,0.45);color:#a5f3fc;border-radius:999px;padding:9px 13px;font-weight:800;letter-spacing:0.01em;width:fit-content;box-shadow:0 10px 26px rgba(34,211,238,0.28);";
              const frontContextStyle =
                "font-size:clamp(0.95rem, 1.6vw, 1.1rem);color:#d6dee9;line-height:1.6;text-align:center;max-width:760px;margin:0 auto;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);border-radius:12px;padding:16px 18px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.14), 0 6px 18px rgba(0,0,0,0.18);";
              const frontStyle =
                "font-weight:800;font-size:clamp(1.4rem, 3vw, 2rem);color:#f8fafc;line-height:1.6;display:flex;align-items:center;justify-content:center;text-align:center;min-height:180px;padding:18px;max-width:680px;margin:0 auto;";
              const backStyle =
                "color:#e6edf3;font-size:0.98rem;line-height:1.6;display:grid;gap:24px;max-width:680px; margin:0 auto;";
              const shellStyle =
                "position:relative;perspective:1200px;transform-style:preserve-3d;transition:transform 0.6s cubic-bezier(0.22,1,0.36,1);width:100%;min-height:360px;";
              const faceBase =
                "position:absolute;inset:0;padding:20px;border-radius:14px;backface-visibility:hidden;background:linear-gradient(150deg,rgba(255,255,255,0.08),rgba(52,30,66,0.34));display:grid;gap:24px;align-content:center;justify-items:center;box-sizing:border-box;";
              const backFace = "transform:rotateY(180deg);";
              const btnFlipStyle =
                "margin-top:12px;display:inline-flex;align-items:center;justify-content:center;gap:10px;padding:14px 18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);background:linear-gradient(135deg,#22d3ee,#4f46e5);color:#f8fafc;font-weight:800;letter-spacing:0.01em;cursor:pointer;box-shadow:0 14px 30px rgba(79,70,229,0.35);width:100%;";
              const actionsRow =
                "display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:16px;width:100%;max-width:100%;margin-left:auto;margin-right:auto;";
              const actionBase =
                "border:none;border-radius:14px;padding:14px 12px;font-weight:800;color:#ffffff;cursor:pointer;box-shadow:0 14px 30px rgba(0,0,0,0.3);letter-spacing:0.01em;transition:transform 0.15s ease, box-shadow 0.15s ease;animation:shinePulse 2.6s ease-in-out infinite;";
              const btnRed = `${actionBase} background:linear-gradient(135deg,#f97373,#ef4444);`;
              const btnYellow = `${actionBase} background:linear-gradient(135deg,#facc15,#f59e0b);`;
              const btnGreen = `${actionBase} background:linear-gradient(135deg,#22c55e,#16a34a);`;
              const dotRow =
                "display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:0;";
              const dotBase =
                "display:inline-flex;align-items:center;justify-content:center;width:36px;height:36px;border-radius:999px;font-weight:800;font-size:0.95rem;box-shadow:0 10px 18px rgba(0,0,0,0.22);animation:shinePulse 3s ease-in-out infinite;";
              const dotRed = `${dotBase} background:linear-gradient(135deg,#f97373,#ef4444);color:#ffffff;`;
              const dotYellow = `${dotBase} background:linear-gradient(135deg,#facc15,#f59e0b);color:#ffffff;`;
              const dotGreen = `${dotBase} background:linear-gradient(135deg,#22c55e,#16a34a);color:#ffffff;`;
              const congratsStyle =
                "padding:16px;border-radius:14px;background:linear-gradient(135deg,rgba(34,211,238,0.22),rgba(79,70,229,0.25));border:1px solid rgba(255,255,255,0.14);color:#e2e8f0;display:grid;gap:16px;place-items:center;text-align:center;";
              const resetBtnStyle =
                "display:inline-flex;align-items:center;gap:8px;padding:12px 16px;border-radius:12px;border:1px solid rgba(255,255,255,0.16);background:linear-gradient(135deg,#22d3ee,#4f46e5);color:#f8fafc;font-weight:800;letter-spacing:0.01em;cursor:pointer;box-shadow:0 14px 30px rgba(79,70,229,0.35);";
              return `
                <div class="deck-box deck-primary deck-static" data-deck-id="${
                  deck.id
                }" data-deck-subject="${subjectId}" data-deck-capitol="${capitolId}" data-card-idx="${currentIdx}" style="${boxStyle}">
                  <div class="deck-header" style="${headerStyle}">
                    <div class="deck-title" style="${titleStyle}">${displayTitle}</div>
                    <span class="deck-score-pill" style="${pillStyle}">${
                cards.length
              } carduri</span>
                  </div>
                  <div class="deck-cards" style="${cardsStyle}">
                    <div class="deck-status-row" style="display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:0;">
                      <div class="deck-dots" style="${dotRow}">
                        <span style="${dotRed}">${redCount}</span>
                        <span style="${dotYellow}">${yellowCount}</span>
                        <span style="${dotGreen}">${greenCount}</span>
                      </div>
                    </div>
                    ${
                      allGreen
                        ? `
                      <div class="deck-card static feature" style="${cardStyle} min-height:auto; gap:18px; padding:28px; max-width:720px;">
                        <div style="${congratsStyle}">
                          <div style="font-weight:800;font-size:1.08rem;">FelicitƒÉri! Cuno»ôti toate conceptele.</div>
                          <button type="button" class="deck-reset-btn" data-deck-reset="${deck.id}" style="${resetBtnStyle}">Ia-le de la capƒÉt</button>
                        </div>
                      </div>`
                        : `
                      <div class="deck-card static feature">
                        <div class="flip-shell" data-flip-shell="${
                          deck.id
                        }" style="${shellStyle}">
                          <div class="flip-face front" style="${faceBase}">
                            ${
                              promptParts.context
                                ? `<div style="${frontContextStyle}">${promptParts.context}</div>`
                                : ""
                            }
                            <div class="deck-front" style="${frontStyle}">${
                            promptParts.main
                          }</div>
                            <button type="button" class="deck-flip-btn" data-flip-target="${
                              deck.id
                            }" style="${btnFlipStyle}">AratƒÉ rƒÉspunsul</button>
                          </div>
                          <div class="flip-face back" style="${faceBase} ${backFace}">
                            <div class="deck-back" style="${backStyle}">
                              <div style="font-weight:800;color:#fff;text-align:center;text-shadow:0 2px 12px rgba(0,0,0,0.45);letter-spacing:0.01em;font-size:135%;">${
                                promptParts.backTitle
                              }:</div>
                              <div style="color:#e6edf3;font-size:1.05rem;font-weight:600;">${
                                backContent.academic
                              }</div>
                              ${
                                backContent.simplified
                                  ? `<div style="background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.14);border-radius:12px;padding:16px 14px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.18);color:#eef2ff;font-weight:700;">${backContent.simplified}</div>`
                                  : ""
                              }
                            </div>
                            <div class="deck-actions" style="${actionsRow}">
                              <button type="button" class="deck-action deck-action-red" data-deck-action="again" style="${btnRed}">Nu am »ôtiut</button>
                              <button type="button" class="deck-action deck-action-yellow" data-deck-action="hard" style="${btnYellow}">Mai am scƒÉpƒÉri</button>
                              <button type="button" class="deck-action deck-action-green" data-deck-action="good" style="${btnGreen}">√él »ôtiu</button>
                            </div>
                          </div>
                        </div>
                       
                      </div>`
                    }
                  </div>
                </div>
              `;
            })
            .join("")}
        </div>`;
      }

      function refreshDeckRow(capitolId) {
        const row = capitoleContainer.querySelector(
          `.deck-row[data-deck-capitol='${capitolId}']`
        );
        if (!row) return;
        const subj = row.dataset.deckSubject || "fph";
        row.outerHTML = renderDeckRow(subj, capitolId);
        const newRow = capitoleContainer.querySelector(
          `.deck-row[data-deck-capitol='${capitolId}']`
        );
        const mountTarget = newRow || capitoleContainer;
        wireDeckInteractions(mountTarget);
        wireTooltips(mountTarget);
        const firstCard = mountTarget.querySelector(".deck-card");
        if (firstCard) {
          firstCard.classList.add("fade-in-card");
          requestAnimationFrame(() =>
            firstCard.classList.add("fade-in-card-active")
          );
          setTimeout(() => {
            firstCard.classList.remove("fade-in-card", "fade-in-card-active");
          }, 320);
        }
        syncDeckHeights(mountTarget);
        const subj2 =
          mountTarget.querySelector(".deck-row")?.dataset.deckSubject;
        updateDeckCompletion(capitolId, subj2 || "fph");
      }

      function syncDeckHeights(root = document) {
        root.querySelectorAll("[data-flip-shell]").forEach((shell) => {
          const front = shell.querySelector(".flip-face.front");
          const back = shell.querySelector(".flip-face.back");
          if (!front || !back) return;
          const h = Math.max(front.scrollHeight, back.scrollHeight, 420);
          shell.style.minHeight = `${h}px`;
          shell.style.height = "";
        });
      }

      function updateDeckCompletion(capitolId, subjectId = "fph") {
        const deckStats = getCapitolDeckStats(capitolId, subjectId);
        const done =
          deckStats.count > 0 && deckStats.sum === deckStats.count * 100;
        const subcap = capitoleContainer
          .querySelector(`.deck-subcap [data-deck-list='${capitolId}']`)
          ?.closest(".deck-subcap");
        if (subcap) {
          const status = subcap.querySelector(".subcap-status");
          if (status) {
            status.classList.toggle("done", done);
            status.textContent = done ? "‚úì" : "";
          }
        }
      }

      function wireDeckInteractions(root = document) {
        const syncHeights = (shell) => {
          const front = shell.querySelector(".flip-face.front");
          const back = shell.querySelector(".flip-face.back");
          if (!front || !back) return;
          requestAnimationFrame(() => {
            const h = Math.max(front.scrollHeight, back.scrollHeight, 420);
            shell.style.minHeight = `${h}px`;
            shell.style.height = "";
          });
        };

        root.querySelectorAll("[data-flip-target]").forEach((btn) => {
          if (btn.dataset.flipBound === "true") return;
          const target = btn.dataset.flipTarget;
          const shell = root.querySelector(`[data-flip-shell=\"${target}\"]`);
          if (!shell) return;
          btn.dataset.flipBound = "true";
          syncHeights(shell);
          btn.addEventListener("click", () => {
            const flipped = shell.dataset.flipped === "true";
            shell.dataset.flipped = flipped ? "false" : "true";
            shell.style.transform = flipped
              ? "rotateY(0deg)"
              : "rotateY(180deg)";
            btn.textContent = flipped ? "AratƒÉ rƒÉspunsul" : "Ascunde rƒÉspunsul";
          });
        });

        root.querySelectorAll(".deck-action").forEach((btn) => {
          if (btn.dataset.deckBound === "true") return;
          btn.dataset.deckBound = "true";
          btn.addEventListener("click", () => {
            const deckBox = btn.closest("[data-deck-id]");
            if (!deckBox) return;
            const deckId = deckBox.dataset.deckId;
            const capitolId =
              deckBox.dataset.deckCapitol ||
              deckBox.closest(".deck-row")?.dataset.deckCapitol;
            const subj = deckBox.dataset.deckSubject || "fph";
            const decks = getDecksForCapitol(capitolId, subj);
            const deck = decks.find((d) => d.id === deckId);
            if (!deck || !deck.cards || !deck.cards.length) return;
            const st = ensureDeckState(deck);
            const currentIdx =
              parseInt(deckBox.dataset.cardIdx || "0", 10) || 0;
            const cardEl = btn.closest(".deck-card");
            if (cardEl) cardEl.classList.add("fade-out");
            const nextIdx = (() => {
              const total = getDeckCards(deck).length;
              for (let offset = 1; offset <= total; offset++) {
                const idx = (currentIdx + offset) % total;
                if (st.statuses[idx] !== "green") return idx;
              }
              return 0;
            })();
            if (btn.dataset.deckAction === "again") {
              st.statuses[currentIdx] = "red";
            } else if (btn.dataset.deckAction === "hard") {
              st.statuses[currentIdx] = "yellow";
            } else if (btn.dataset.deckAction === "good") {
              st.statuses[currentIdx] = "green";
            }
            st.idx = nextIdx;
            deckState[deckId] = st;
            saveDeckState();
            setTimeout(() => {
              refreshDeckRow(capitolId);
              renderCardProgress();
              const subj = deckBox.dataset.deckSubject || "fph";
              updateCapitolPill(capitolId, subj);
              updateDeckCompletion(capitolId, subj);
              syncDeckHeights(capitoleContainer);
            }, 260);
          });
        });

        root.querySelectorAll(".deck-reset-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const deckBox = btn.closest("[data-deck-id]");
            if (!deckBox) return;
            const deckId = deckBox.dataset.deckId;
            const capitolId =
              deckBox.dataset.deckCapitol ||
              deckBox.closest(".deck-row")?.dataset.deckCapitol;
            const subj = deckBox.dataset.deckSubject || "fph";
            const decks = getDecksForCapitol(capitolId, subj);
            const deck = decks.find((d) => d.id === deckId);
            if (!deck || !deck.cards || !deck.cards.length) return;
            const st = ensureDeckState(deck);
            st.statuses = Array(getDeckCards(deck).length).fill("red");
            st.idx = 0;
            deckState[deckId] = st;
            saveDeckState();
            refreshDeckRow(capitolId);
            renderCardProgress();
            if (
              currentSubject &&
              currentSubject.capitole &&
              detailOverlay.classList.contains("show")
            ) {
              rerenderSubjectCapitolePreserveState(currentSubject);
            }
          });
        });
      }

      function wireInlineQuizButtons(container, subject) {
        if (!container) return;
        container.querySelectorAll("[data-topic]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const topicId = btn.dataset.topic;
            const topic = subject.topics.find((t) => t.id === topicId);
            openQuiz(subject, topic, container);
          });
        });
        updateBarWidths(container, false);
      }

      function setChevron(btn, expanded) {
        const chev = btn.querySelector(".chevron");
        if (!chev) return;
        chev.style.transform = expanded ? "rotate(180deg)" : "rotate(0deg)";
      }

      function scrollIntoModalView(target, offset = 0) {
        const modal = detailOverlay.querySelector(".modal");
        if (!modal || !target) return;
        const rect = target.getBoundingClientRect();
        const mRect = modal.getBoundingClientRect();
        const top = modal.scrollTop + (rect.top - mRect.top) - offset;
        modal.scrollTo({ top: Math.max(top, 0), behavior: "smooth" });
      }

      function barStyleFor(subjectId) {
        const style = subjectBars[subjectId] || subjectBars.fph;
        return `--bar-base:${style.base}; --bar-glow:${style.glow};`;
      }

      function pillColorClass(val) {
        if (val >= 100) return "green";
        if (val >= 60) return "yellow";
        if (val >= 10) return "orange";
        return "red";
      }

      function pillIcon(val) {
        if (val >= 100) return "‚úÖ";
        if (val >= 60) return "üí°";
        if (val >= 10) return "ü§ì";
        return "üí§";
      }

      function wireTooltips(scope = document) {
        const tips = scope.querySelectorAll(".tip");
        tips.forEach((tip) => {
          if (tip.dataset.tipBound === "true") return;
          tip.dataset.tipBound = "true";
          const box = tip.querySelector(".tooltip-box");
          if (!box) return;
          let floating = null;
          const show = () => {
            const rect = tip.getBoundingClientRect();
            if (!floatingTooltip) {
              floatingTooltip = document.createElement("div");
              floatingTooltip.className = "tooltip-floating";
              document.body.appendChild(floatingTooltip);
            }
            floating = floatingTooltip;
            floating.innerHTML = box.innerHTML;
            const bRect = floating.getBoundingClientRect();
            let left = rect.left + rect.width / 2 - bRect.width / 2;
            left = Math.max(
              8,
              Math.min(left, window.innerWidth - bRect.width - 8)
            );
            let top = rect.top - bRect.height - 8;
            if (top < 8) top = rect.bottom + 8;
            floating.style.left = `${left}px`;
            floating.style.top = `${top}px`;
            floating.style.display = "block";
            floating.style.opacity = "1";
          };
          const hide = () => {
            if (floatingTooltip) {
              floatingTooltip.style.display = "none";
              floatingTooltip.style.opacity = "0";
            }
          };
          tip.addEventListener("mouseenter", show);
          tip.addEventListener("mousemove", show);
          tip.addEventListener("mouseleave", hide);
        });
      }

      function applySubjectBar(subject) {
        if (!subject) return;
        ensurePhedData(subject);
        const avg = subjectAverage(subject);
        subjectProgressLabel.textContent = `Parcurs ${avg}%`;
        if (subjectProgressBar) {
          subjectProgressBar.style.cssText = `width:${avg}%; ${barStyleFor(
            subject.id
          )}`;
        }
      }

      function updateBarWidths(container, animate, onlyTopicId) {
        if (!container) return;
        const bars = container.querySelectorAll(".progress-bar[data-target]");
        bars.forEach((bar) => {
          if (onlyTopicId) {
            const parentTopic = bar.closest("[data-topic-container]");
            if (
              !parentTopic ||
              parentTopic.dataset.topicContainer !== onlyTopicId
            )
              return;
          }
          const target = Number(bar.dataset.target || 0);
          const progressWrap = bar.parentElement;
          if (progressWrap) {
            let valEl = progressWrap.querySelector(".progress-value");
            if (!valEl) {
              valEl = document.createElement("div");
              valEl.className = "progress-value";
              progressWrap.appendChild(valEl);
            }
            valEl.textContent = `${target}%`;
            const pillColor = progressWrap
              .closest(".pill-course")
              ?.querySelector(".pill-percent");
            if (pillColor) {
              const match = pillColor.textContent.match(/(\d+)/);
              const val = match ? Number(match[1]) : 0;
              pillColor.classList.remove("red", "orange", "yellow", "green");
              pillColor.classList.add(pillColorClass(val));
              const ico = pillColor.querySelector(".pill-ico");
              const valSpan = pillColor.querySelector(".pill-val");
              if (ico) ico.textContent = pillIcon(val);
              if (valSpan) valSpan.textContent = `${val}%`;
            }
          }
          if (animate) {
            bar.style.width = "0%";
            bar.offsetHeight; // reflow
            requestAnimationFrame(() => {
              bar.style.width = `${target}%`;
            });
          } else {
            bar.style.width = `${target}%`;
          }
        });
      }

      function ensureFphData(subject) {
        if (!subject || subject.id !== "fph") return;
        const data = window.FPH_CONTENT || {};
        if (!subject.capitole?.length) {
          subject.capitole = data.capitole || [];
        }
        if (!subject.topics?.length) {
          subject.topics = data.topics || [];
        }
      }

      function ensurePhedData(subject) {
        if (!subject || subject.id !== "phed") return;
        const data = window.PHED_CONTENT || {};
        if (!subject.capitole?.length) {
          subject.capitole = data.capitole || [];
        }
        if (!subject.topics?.length) {
          subject.topics = (window.PHED_QUIZ || []).map((q) => ({
            id: q.id,
            title: q.title,
            // pƒÉstreazƒÉ primul item pentru compatibilitate, dar expune »ôi lista completƒÉ
            question: q.questions?.[0] || null,
            questions: q.questions || [],
          }));
        }
      }

      function rerenderSubjectCapitolePreserveState(subject) {
        if (!subject || !subject.capitole?.length) return;
        const openCapitole = new Set(
          Array.from(
            capitoleContainer.querySelectorAll(".subcap-list.expanded")
          ).map((el) => el.id?.replace("-subs", ""))
        );
        const openSubcaps = new Set(
          Array.from(
            capitoleContainer.querySelectorAll(".subcap-quiz-list.expanded")
          ).map((el) => el.dataset.quizList)
        );
        const openDecks = new Set(
          Array.from(
            capitoleContainer.querySelectorAll(".deck-collapsible.expanded")
          ).map((el) => el.dataset.deckList)
        );
        renderCapitole(subject);
        // re-open previous states
        capitoleContainer.querySelectorAll(".subcap-list").forEach((el) => {
          const id = el.id?.replace("-subs", "");
          if (id && openCapitole.has(id)) {
            el.classList.add("expanded");
            const btn = capitoleContainer.querySelector(
              `[data-toggle='${id}']`
            );
            if (btn) setChevron(btn, true);
          }
        });
        capitoleContainer
          .querySelectorAll(".subcap-quiz-list")
          .forEach((el) => {
            const id = el.dataset.quizList;
            if (id && openSubcaps.has(id)) {
              el.classList.add("expanded");
              const btn = el.previousElementSibling;
              if (btn?.classList.contains("toggle-btn")) setChevron(btn, true);
              if (el.dataset.quizIds) {
                const ids = el.dataset.quizIds.split(",").filter(Boolean);
                el.innerHTML = renderInlineQuizList(subject, ids);
                wireInlineQuizButtons(el, subject);
              }
            }
          });
        capitoleContainer
          .querySelectorAll(".deck-collapsible")
          .forEach((el) => {
            const id = el.dataset.deckList;
            if (id && openDecks.has(id)) {
              el.classList.add("expanded");
              const btn = capitoleContainer.querySelector(
                `[data-deck-toggle='${id}']`
              );
              if (btn) setChevron(btn, true);
            }
          });
      }

      function shuffleIndices(len) {
        const arr = Array.from({ length: len }, (_, i) => i);
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function launchConfetti() {
        const container = detailOverlay.querySelector(".modal");
        if (!container) return;
        for (let i = 0; i < 16; i++) {
          const c = document.createElement("div");
          c.className = "confetti";
          c.style.left = `${Math.random() * 100}%`;
          c.style.background = i % 2 ? "#ffb703" : "#6be8f7";
          c.style.animationDelay = `${Math.random() * 0.2}s`;
          container.appendChild(c);
          setTimeout(() => c.remove(), 1000);
        }
      }

      function addEmojiPop(targetEl) {
        if (!targetEl) return;
        const rect = targetEl.getBoundingClientRect();
        const containerRect = detailOverlay.getBoundingClientRect();
        const emoji = document.createElement("div");
        emoji.className = "emoji-pop";
        emoji.textContent = "üéâ";
        emoji.style.left = `${Math.min(
          rect.left + rect.width / 2 - containerRect.left,
          containerRect.width - 24
        )}px`;
        emoji.style.top = `${rect.top - containerRect.top - 10}px`;
        detailOverlay.appendChild(emoji);
        setTimeout(() => emoji.remove(), 900);
      }

      function highlightCompletedTopic(listEl, topicId) {
        if (!listEl || !topicId) return;
        const item = listEl.querySelector(
          `[data-topic-container='${topicId}']`
        );
        if (!item) return;
        item.classList.add("completed-highlight");
        setTimeout(() => item.classList.remove("completed-highlight"), 900);
      }

      function openQuiz(subject, topic, sourceListEl) {
        currentTopic = topic;
        currentSubject = subject;
        currentQuizListEl = sourceListEl || null;
        if (!topic || !(topic.question || topic.questions)) return;
        const questions =
          topic.questions || (topic.question ? [topic.question] : []);
        currentQuestions = questions;
        quizPanelTitle.textContent = `${topic.title}`;
        quizPanelContent.innerHTML = questions
          .map((q, qIdx) => {
            const isMulti = Array.isArray(q.answer);
            const inputType = isMulti ? "checkbox" : "radio";
            const order = shuffleIndices(q.options.length);
            const optionsHtml = order
              .map(
                (idx) => `
                <label class="choice">
                  <input type="${inputType}" name="q-${qIdx}" value="${idx}"> ${q.options[idx]}
                </label>
              `
              )
              .join("");
            return `
              <div class="quiz-question" data-q="${qIdx}">
                <h4>${q.text}</h4>
                ${optionsHtml}
              </div>
            `;
          })
          .join('<hr class="quiz-sep">');
        wireTooltips(quizPanelContent);
        quizPanelContent.scrollTop = 0;
        const modalEl = detailOverlay.querySelector(".modal");
        if (modalEl) modalEl.scrollTo({ top: 0, behavior: "auto" });
        quizPanelFeedback.className = "feedback info";
        quizPanelFeedback.textContent =
          "RƒÉspunde la toate √ÆntrebƒÉrile »ôi trimite pentru validare.";
        quizPanel.classList.remove("hidden", "exit", "complete");
        requestAnimationFrame(() => quizPanel.classList.add("show"));
        quizPanelSubmit.classList.remove("hidden");
        quizPanelRestart.classList.add("hidden");
        quizPanelBack.classList.remove("hidden");
        quizPanelBack.textContent = "‚Üê √énapoi";
        quizPanelBack.classList.remove("split", "primary");
        quizPanelBack.classList.add("secondary");
        quizPanelRestart.classList.remove("split", "primary");
        quizPanelRestart.classList.add("secondary");
        quizCompleted = false;
        capitoleContainer.classList.add("hidden");
        topicsContainer.classList.add("hidden");
        pdfLink.classList.add("hidden");
        backToList.classList.remove("hidden");
      }

      function submitQuizAnswer() {
        if (!currentTopic || !currentQuestions.length) return;
        let answeredAll = true;
        let correctCount = 0;

        // clear previous state
        quizPanelContent.querySelectorAll(".choice").forEach((c) => {
          c.classList.remove("correct", "incorrect");
        });
        quizPanelContent.querySelectorAll(".quiz-question").forEach((q) => {
          q.classList.remove("q-correct", "q-incorrect");
        });

        currentQuestions.forEach((q, idx) => {
          const inputs = Array.from(
            quizPanelContent.querySelectorAll(`input[name='q-${idx}']:checked`)
          );
          const isMulti = Array.isArray(q.answer);
          if (!inputs.length) {
            answeredAll = false;
            return;
          }
          let isCorrect = false;
          if (isMulti) {
            const answerSet = new Set(q.answer);
            const selectedVals = inputs.map((i) => Number(i.value));
            const hasAll = selectedVals.every((v) => answerSet.has(v));
            const noExtras = selectedVals.length === answerSet.size;
            isCorrect = hasAll && noExtras;
            inputs.forEach((inp) => {
              const label = inp.closest(".choice");
              if (!label) return;
              label.classList.add(
                answerSet.has(Number(inp.value)) ? "correct" : "incorrect"
              );
            });
          } else {
            const selected = inputs[0];
            const val = Number(selected.value);
            isCorrect = val === q.answer;
            const label = selected.closest(".choice");
            if (label) {
              label.classList.add(isCorrect ? "correct" : "incorrect");
            }
          }
          if (isCorrect) correctCount += 1;
          const questionWrapper = inputs[0]?.closest(".quiz-question");
          if (questionWrapper) {
            questionWrapper.classList.add(
              isCorrect ? "q-correct" : "q-incorrect"
            );
          }
        });

        if (!answeredAll) {
          quizPanelFeedback.className = "feedback info";
          quizPanelFeedback.textContent =
            "CompleteazƒÉ toate √ÆntrebƒÉrile √Ænainte de a trimite.";
          quizPanelFeedback.style.display = "block";
          return;
        }

        const allCorrect = correctCount === currentQuestions.length;
        const newVal = allCorrect ? 100 : 50;
        setTopicProgress(currentTopic.id, newVal);

        quizPanelFeedback.className = allCorrect
          ? "feedback success"
          : "feedback info";
        quizPanelFeedback.textContent = allCorrect
          ? `Perfect! ${correctCount}/${currentQuestions.length} corecte.`
          : `${correctCount}/${currentQuestions.length} corecte. CorecteazƒÉ rƒÉspunsurile marcate »ôi retrimite.`;
        quizPanelFeedback.style.display = "block";

        if (allCorrect) {
          quizPanelSubmit.classList.add("hidden");
          quizPanelRestart.classList.remove("hidden");
          quizPanelBack.classList.remove("hidden");
          quizPanelBack.textContent = "√éntoarce-te la QUIZuri";
          quizPanelRestart.textContent = "Reia QUIZul";
          quizPanelBack.classList.add("split");
          quizPanelRestart.classList.add("split");
          quizPanelBack.classList.remove("secondary");
          quizPanelBack.classList.add("primary");
          quizPanelRestart.classList.remove("primary");
          quizPanelRestart.classList.add("secondary");
          quizCompleted = true;
          lastCompletedTopicId = currentTopic?.id || null;
        } else {
          quizPanelSubmit.classList.remove("hidden");
          quizPanelRestart.classList.add("hidden");
          quizPanelBack.classList.remove("hidden");
          quizPanelBack.textContent = "‚Üê √énapoi";
          quizPanelBack.classList.remove("split");
          quizPanelRestart.classList.remove("split");
          quizPanelBack.classList.remove("primary");
          quizPanelBack.classList.add("secondary");
          quizCompleted = false;
          lastCompletedTopicId = null;
        }
      }

      function restartQuiz() {
        if (currentSubject && currentTopic) {
          openQuiz(currentSubject, currentTopic, currentQuizListEl);
        }
      }

      function goBackToSubcap() {
        if (quizCompleted) {
          quizPanel.classList.remove("show");
          quizPanel.classList.add("complete");
          launchConfetti();
          setTimeout(() => {
            quizPanel.classList.add("hidden");
            quizPanel.classList.remove("complete", "show", "exit");
            syncDeckHeights(capitoleContainer);
          }, 300);
        } else {
          quizPanel.classList.remove("show");
          quizPanel.classList.add("exit");
          setTimeout(() => {
            quizPanel.classList.add("hidden");
            quizPanel.classList.remove("exit", "show", "complete");
            syncDeckHeights(capitoleContainer);
          }, 220);
        }
        quizPanelContent.innerHTML = "";
        quizPanelFeedback.textContent = "";
        quizPanelSubmit.classList.remove("hidden");
        quizPanelRestart.classList.add("hidden");
        quizPanelBack.classList.remove("hidden");
        quizPanelBack.textContent = "‚Üê √énapoi";
        quizPanelBack.classList.remove("split");
        quizPanelRestart.classList.remove("split");
        quizPanelBack.classList.remove("primary");
        quizPanelBack.classList.add("secondary");
        const lastTopicId = currentTopic
          ? currentTopic.id
          : lastCompletedTopicId;
        currentQuestions = [];
        currentTopic = null;
        pdfLink.classList.remove("hidden");
        backToList.classList.add("hidden");
        // keep subcap/quiz list open
        let workingQuizList = currentQuizListEl;
        if (currentQuizListEl) {
          const subcapId = currentQuizListEl.dataset.quizList;
          const refreshed =
            subcapId &&
            capitoleContainer.querySelector(`[data-quiz-list='${subcapId}']`);
          workingQuizList = refreshed || currentQuizListEl;
          workingQuizList.classList.add("expanded");
          const toggleBtn = workingQuizList.previousElementSibling;
          if (toggleBtn) setChevron(toggleBtn, true);
          const ancestorCollapsible = workingQuizList.closest(".collapsible");
          if (ancestorCollapsible)
            ancestorCollapsible.classList.add("expanded");
          if (refreshed && refreshed.dataset.quizIds) {
            const ids = refreshed.dataset.quizIds.split(",").filter(Boolean);
            refreshed.innerHTML = renderInlineQuizList(currentSubject, ids);
            wireInlineQuizButtons(refreshed, currentSubject);
          }
        }

        if (
          currentSubject &&
          currentSubject.capitole &&
          currentSubject.capitole.length
        ) {
          capitoleContainer.classList.remove("hidden");
          if (quizCompleted && workingQuizList) {
            const topicId = lastCompletedTopicId;
            const targetItem =
              workingQuizList.querySelector(
                `[data-topic-container='${topicId}']`
              ) || workingQuizList;
            targetItem.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
            setTimeout(() => {
              highlightCompletedTopic(workingQuizList, topicId);
              const item =
                workingQuizList.querySelector(
                  `[data-topic-container='${topicId}']`
                ) || workingQuizList;
              item.classList.add("completed-highlight");
              setTimeout(
                () => item.classList.remove("completed-highlight"),
                1900
              );
              addEmojiPop(item);
              updateBarWidths(workingQuizList, true, topicId);
            }, 320);
          } else if (lastTopicId && workingQuizList) {
            const targetItem =
              workingQuizList.querySelector(
                `[data-topic-container='${lastTopicId}']`
              ) || workingQuizList;
            targetItem.scrollIntoView({ behavior: "smooth", block: "center" });
          }
        } else {
          topicsContainer.classList.remove("hidden");
          capitoleContainer.classList.add("hidden");
          renderTopics(currentSubject);
          if (quizCompleted && lastTopicId) {
            updateBarWidths(topicsContainer, true, lastTopicId);
          }
          if (lastTopicId) {
            const targetBtn = topicsContainer.querySelector(
              `[data-topic='${lastTopicId}']`
            );
            const targetItem = targetBtn ? targetBtn.closest(".topic") : null;
            (targetItem || targetBtn || topicsContainer).scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }
        }
      }

      document.addEventListener("keydown", (e) => {
        if (e.key !== "Escape") return;
        if (detailOverlay.classList.contains("show")) {
          closeModal(true);
        }
      });

      document.addEventListener("keydown", (e) => {
        if (e.shiftKey && (e.key === "q" || e.key === "Q")) {
          e.preventDefault();
          resetAllProgress();
        }
      });
    </script>
  </body>
</html>
