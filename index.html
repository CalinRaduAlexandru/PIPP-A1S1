<!DOCTYPE html>
<html lang="ro">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" type="image/svg+xml" href="favicon.png" />
    <link rel="preload" href="Assets/trophy.png" as="image" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      rel="preload"
      as="style"
      href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Archivo+Black&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700;800&family=Archivo+Black&display=swap"
    />
    <title>PIPP A1S1</title>
    <style>
      :root {
        --bg: #0d1117;
        --card: #111827;
        --text: #e6edf3;
        --muted: #9aa5b1;
        --shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
        --fph: #ffb3b3;
        --fph-2: #f16c6c;
        --fped: #ffd6a1;
        --fped-2: #f3a742;
        --pdezv: #d8dfb6;
        --pdezv-2: #8f9958;
        --phed: #ffc5e6;
        --phed-2: #ef7abf;
        --pedcom: #d4c7ff;
        --pedcom-2: #8d7cf5;
        --lr: #b0e1ff;
        --lr-2: #5ca6ff;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        min-height: 100vh;
        background: radial-gradient(
            circle at 20% 20%,
            rgba(255, 183, 3, 0.08),
            transparent 35%
          ),
          radial-gradient(
            circle at 80% 0%,
            rgba(100, 255, 218, 0.12),
            transparent 30%
          ),
          var(--bg);
        font-family: "Manrope", "Space Grotesk", "Helvetica Neue", Arial,
          sans-serif;
        font-synthesis: none;
        color: var(--text);
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 32px 18px;
      }

      .shell {
        width: min(1080px, 96vw);
        position: relative;
        overflow: hidden;
      }

      .intro {
        background: linear-gradient(
          135deg,
          rgba(255, 183, 3, 0.18),
          rgba(100, 255, 218, 0.22)
        );
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 20px;
        padding: 34px 36px;
        box-shadow: var(--shadow);
        text-align: center;
        transform-origin: center;
        transition: transform 0.7s ease, opacity 0.7s ease;
        position: relative;
        z-index: 2;
      }

      .intro h1 {
        font-size: 2.5rem;
        letter-spacing: -0.03em;
        margin-bottom: 12px;
      }

      .intro p {
        color: var(--muted);
        font-size: 1rem;
        margin-bottom: 20px;
      }

      .start-btn {
        background: #000;
        color: #fff;
        border: none;
        padding: 14px 22px;
        border-radius: 999px;
        font-size: 1rem;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.25);
        transition: transform 0.25s ease, box-shadow 0.25s ease;
      }

      .start-btn:hover {
        transform: translateY(-2px) scale(1.02);
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.32);
      }
      .start-btn:active {
        transform: translateY(0) scale(0.99);
      }

      .map {
        margin-top: 26px;
        background: var(--card);
        border: 1px solid rgba(255, 255, 255, 0.04);
        border-radius: 20px;
        padding: 26px;
        box-shadow: var(--shadow);
        transform: scale(1);
        opacity: 1;
        transition: transform 0.7s ease, opacity 0.7s ease;
        position: relative;
        z-index: 1;
      }

      .map.visible {
        transform: scale(1);
        opacity: 1;
      }
      .intro.hidden {
        transform: scale(0.9);
        opacity: 0;
      }

      .map h2 {
        font-size: 1.4rem;
        margin-bottom: 18px;
        color: #ffffff;
        letter-spacing: -0.02em;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 16px;
      }

      @media (min-width: 1120px) {
        .grid {
          grid-template-columns: repeat(3, minmax(0, 1fr));
        }
      }

      @keyframes shinePulse {
        0% {
          box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.18),
            0 10px 28px rgba(0, 0, 0, 0.28);
          filter: brightness(1);
        }
        50% {
          box-shadow: 0 0 0 8px rgba(255, 255, 255, 0.04),
            0 14px 32px rgba(0, 0, 0, 0.32);
          filter: brightness(1.05);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(255, 255, 255, 0),
            0 10px 28px rgba(0, 0, 0, 0.28);
          filter: brightness(1);
        }
      }

      @keyframes shineSweep {
        0%,
        68% {
          transform: translateX(-140%);
        }
        82%,
        100% {
          transform: translateX(140%);
        }
      }

      @keyframes shineHover {
        0% {
          transform: translateX(-140%);
        }
        100% {
          transform: translateX(140%);
        }
      }

      @keyframes goldGlow {
        0%,
        70%,
        100% {
          box-shadow: 0 18px 44px rgba(180, 120, 20, 0.18);
          filter: brightness(1);
        }
        82% {
          box-shadow: 0 24px 60px rgba(216, 162, 70, 0.4);
          filter: brightness(1.06);
        }
      }

      .deck-card.fade-out {
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 0.28s ease, transform 0.28s ease;
      }

      .deck-card.fade-in-card {
        opacity: 0;
        transform: translateY(8px);
      }

      .deck-card.fade-in-card.fade-in-card-active {
        opacity: 1;
        transform: translateY(0);
        transition: opacity 0.28s ease, transform 0.28s ease;
      }

      @media (max-width: 1119px) {
        .grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      @media (max-width: 768px) {
        .flip-shell {
          min-height: 600px !important;
        }

        .deck-header {
          padding: 12px !important;
        }

        .deck-score-pill {
          padding: 6px 12px !important;
        }
      }

      @media (max-width: 786px) {
        .grid {
          grid-template-columns: repeat(1, minmax(0, 1fr));
        }
      }

      .support-box {
        margin-top: 72px;
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        text-align: center;
      }

      .support-hint {
        color: rgba(230, 237, 243, 0.7);
        font-weight: 600;
        letter-spacing: -0.01em;
      }

      .whatsapp-btn {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        padding: 14px 20px;
        border-radius: 999px;
        background: linear-gradient(135deg, #25d366, #16a34a);
        color: #ffffff;
        font-weight: 800;
        letter-spacing: -0.01em;
        text-decoration: none;
        box-shadow: 0 18px 40px rgba(22, 163, 74, 0.3),
          0 0 0 1px rgba(255, 255, 255, 0.08);
        position: relative;
        overflow: hidden;
        transition: transform 0.25s ease, box-shadow 0.25s ease;
      }

      .whatsapp-btn::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          120deg,
          rgba(255, 255, 255, 0) 0%,
          rgba(255, 255, 255, 0.18) 45%,
          rgba(255, 255, 255, 0) 90%
        );
        transform: translateX(-120%);
        transition: transform 0.5s ease;
      }

      .whatsapp-btn:hover {
        transform: translateY(-2px) scale(1.01);
        box-shadow: 0 20px 44px rgba(22, 163, 74, 0.38),
          0 0 0 1px rgba(255, 255, 255, 0.08);
      }

      .whatsapp-btn:hover::after {
        transform: translateX(120%);
      }

      .whatsapp-icon {
        width: 33px;
        height: 33px;
        border-radius: 50%;
        background: #ffffff;
        display: grid;
        place-items: center;
        box-shadow: 0 0 0 6px rgba(12, 21, 15, 0.08);
        position: relative;
        overflow: visible;
      }

      .whatsapp-icon::after {
        content: "";
        position: absolute;
        inset: 0;
        border-radius: 50%;
        box-shadow: 0 0 0 0 rgba(37, 211, 102, 0.45);
        animation: pulseRing 2.8s ease-out infinite;
      }

      .whatsapp-icon svg {
        width: 18px;
        height: 18px;
        fill: #25d366;
      }

      @keyframes pulseRing {
        0% {
          transform: scale(0.9);
          opacity: 0.7;
          box-shadow: 0 0 0 0 rgba(37, 211, 102, 0.45);
        }
        60% {
          transform: scale(1.25);
          opacity: 0;
          box-shadow: 0 0 0 16px rgba(37, 211, 102, 0);
        }
        100% {
          transform: scale(0.9);
          opacity: 0.7;
          box-shadow: 0 0 0 0 rgba(37, 211, 102, 0.45);
        }
      }

      @media (max-width: 768px) {
        .support-box {
          margin-top: 40px;
          margin-bottom: 40px;
        }
        .whatsapp-btn {
          width: 100%;
          justify-content: center;
        }
      }

      .card.locked {
        position: relative;
        opacity: 0.75;
        filter: saturate(0.55);
        pointer-events: none;
        border: none !important;
      }

      .card.locked .lock-overlay {
        position: absolute;
        inset: 0;
        background: radial-gradient(
            circle at 40% 35%,
            rgba(255, 255, 255, 0.16),
            rgba(255, 255, 255, 0)
          ),
          rgba(8, 12, 22, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        color: #e2e8f0;
        font-weight: 800;
        letter-spacing: 0.01em;
        border-radius: 16px;
        z-index: 2;
      }

      .lock-overlay .lock-icon {
        width: 64px;
        height: 64px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.16);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.3rem;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.18),
          0 10px 22px rgba(0, 0, 0, 0.22);
        animation: lockPulse 3.8s ease-in-out infinite;
      }

      .lock-overlay .lock-icon svg {
        width: 28px;
        height: 28px;
      }

      @keyframes lockPulse {
        0% {
          transform: scale(1);
          box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.18),
            0 10px 22px rgba(0, 0, 0, 0.22);
        }
        50% {
          transform: scale(1.08);
          box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2),
            0 14px 28px rgba(0, 0, 0, 0.26);
        }
        100% {
          transform: scale(1);
          box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.18),
            0 10px 22px rgba(0, 0, 0, 0.22);
        }
      }

      .card {
        border-radius: 18px;
        padding: 16px 18px;
        color: #0b0d10;
        position: relative;
        overflow: hidden;
        cursor: pointer;
        transition: transform 0.25s ease, box-shadow 0.25s ease;
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.26),
          inset 0 1px 0 rgba(255, 255, 255, 0.18);
      }

      .card::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(
          120deg,
          rgba(255, 255, 255, 0) 0%,
          rgba(255, 255, 255, 0.18) 45%,
          rgba(255, 255, 255, 0) 90%
        );
        transform: translateX(-140%);
        transition: transform 0.5s ease;
        pointer-events: none;
      }

      .card:hover::after {
        transform: translateX(140%);
      }

      .card:hover {
        transform: translateY(-3px) scale(1.02);
        box-shadow: 0 16px 36px rgba(0, 0, 0, 0.24);
      }
      .card.zoomed {
        transform: scale(1.05);
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.28);
      }

      .card-header {
        position: relative;
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 12px;
        align-items: center;
        margin-bottom: 6px;
      }

      .card.completed {
        background: linear-gradient(
          145deg,
          rgba(255, 235, 190, 0.95),
          rgba(242, 190, 92, 0.95)
        );
        border: 1px solid rgba(224, 165, 72, 0.6);
        box-shadow: 0 24px 70px rgba(212, 170, 90, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.28);
      }

      .card.completed .card-header::before,
      .card.completed .card-header::after {
        content: none;
      }

      .card.completed h3 {
        color: #6a3f00;
      }

      .card.completed .abbr {
        color: rgba(86, 54, 0, 0.7);
      }

      .card.completed .progress {
        box-shadow: 0 0 18px rgba(212, 170, 90, 0.45),
          inset 0 1px 0 rgba(255, 255, 255, 0.25);
      }

      .progress-bar.trophy {
        background: linear-gradient(135deg, #f6d365, #f1b24a);
        box-shadow: 0 0 18px rgba(214, 169, 86, 0.75);
        background-image: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.28),
          rgba(255, 255, 255, 0.08)
        );
        animation: none;
        background-size: auto;
      }

      .screen-confetti {
        position: fixed;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
        z-index: 9999;
      }

      .screen-confetti .confetti-piece {
        position: absolute;
        top: -20px;
        width: 10px;
        height: 16px;
        border-radius: 2px;
        background: var(--confetti-color);
        left: var(--confetti-left);
        animation: screenConfettiFall var(--confetti-dur) ease-out forwards;
        transform: rotate(var(--confetti-rot));
        opacity: 0.95;
      }

      @keyframes screenConfettiFall {
        0% {
          transform: translateY(0) rotate(var(--confetti-rot));
        }
        100% {
          transform: translateY(120vh) rotate(360deg);
          opacity: 0;
        }
      }

      .congrats-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(8, 12, 18, 0.55);
        display: grid;
        place-items: center;
        z-index: 9998;
      }

      .congrats-popup {
        width: min(520px, 92vw);
        min-height: 360px;
        border-radius: 22px;
        padding: 62px 26px;
        background: radial-gradient(
            circle at 50% 35%,
            rgba(255, 255, 255, 0.86),
            rgba(255, 255, 255, 0.18) 60%
          ),
          linear-gradient(145deg, #fbe6ac, #f1b950);
        color: #3a2500;
        border: 1px solid rgba(217, 158, 56, 0.6);
        box-shadow: 0 24px 60px rgba(0, 0, 0, 0.4);
        text-align: center;
        position: relative;
        animation: popupRise 0.4s ease;
        user-select: none;
        cursor: default;
      }

      .congrats-popup,
      .congrats-popup * {
        user-select: none;
        cursor: default;
      }

      .congrats-popup.animate {
        animation: popupRise 0.4s ease, pulseCongrats 0.8s ease-in-out 3 0.4s,
          fadeOutSmooth 0.6s ease 2.8s forwards;
      }

      .congrats-popup.animate::after {
        content: "";
        position: absolute;
        inset: -14px;
        border-radius: inherit;
        background: radial-gradient(
          circle,
          rgba(255, 220, 120, 0.35),
          rgba(255, 220, 120, 0)
        );
        opacity: 0;
        pointer-events: none;
        animation: pulseGlow 0.9s ease-in-out 3 0.4s;
        z-index: -1;
      }

      .congrats-trophy {
        width: 216px;
        height: 216px;
        flex-shrink: 0;
        margin: 0 auto 10px;
        background: url("Assets/trophy.png") center/contain no-repeat;
        filter: drop-shadow(0 12px 24px rgba(120, 78, 6, 0.45));
      }

      .congrats-title {
        font-size: 3.4rem;
        font-family: "Archivo Black", "Manrope", "Space Grotesk",
          "Helvetica Neue", Arial, sans-serif;
        font-weight: 900;
        letter-spacing: -0.02em;
        display: grid;
        gap: 4px;
        color: #ffffff;
        text-shadow: 0 1px 3px rgba(120, 78, 6, 0.35);
      }

      .congrats-title span:last-child {
        font-size: 1.3rem;
        font-weight: 400;
      }

      @keyframes popupRise {
        from {
          transform: translateY(12px) scale(0.96);
          opacity: 0;
        }
        to {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
      }

      @keyframes pulseCongrats {
        0% {
          transform: translateY(0) scale(1);
          filter: brightness(1);
        }
        50% {
          transform: translateY(-2px) scale(1.02);
          filter: brightness(1.12);
        }
        100% {
          transform: translateY(0) scale(1);
          filter: brightness(1);
        }
      }

      @keyframes fadeOutSmooth {
        from {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
        to {
          opacity: 0;
          transform: translateY(8px) scale(0.98);
        }
      }

      @keyframes pulseGlow {
        0% {
          opacity: 0.2;
          transform: scale(0.95);
        }
        50% {
          opacity: 0.48;
          transform: scale(1.16);
        }
        100% {
          opacity: 0.16;
          transform: scale(1.22);
        }
      }

      .card h3 {
        font-size: 1.5rem;
        margin-bottom: 16px;
        font-weight: 700;
        line-height: 1.4;
        display: -webkit-box;
        line-clamp: 2;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        opacity: 0.7;
        margin-left: 10px;
      }

      @media (min-width: 900px) {
        .modal h3 {
          font-size: 1.625rem;
        }
      }

      .card .icon-stack {
        display: grid;
        justify-items: center;
        gap: 6px;
        position: relative;
      }

      .card.completed .icon {
        background-color: #f9edc7;
        box-shadow: inset 0 6px 12px rgba(255, 255, 255, 0.75),
          inset 0 -10px 14px rgba(120, 78, 6, 0.18),
          0 10px 24px rgba(120, 78, 6, 0.18), 0 0 0 2px rgba(255, 255, 255, 0.6);
        filter: sepia(0.7) saturate(1.5) hue-rotate(-6deg) brightness(1);
      }

      .card.completed .progress-value {
        color: #fff6da;
      }

      .card .icon {
        width: 96px;
        height: 96px;
        aspect-ratio: 1 / 1;
        border-radius: 50%;
        position: relative;
        background-color: #fff;
        background-image: var(--icon-bg, none),
          radial-gradient(
            circle at 30% 28%,
            rgba(255, 255, 255, 0.98),
            rgba(255, 255, 255, 0.72)
          ),
          radial-gradient(
            circle at 70% 70%,
            rgba(0, 0, 0, 0.06),
            rgba(0, 0, 0, 0)
          );
        background-size: 68%, 100%, 100%;
        background-position: center, center, center;
        background-repeat: no-repeat;
        display: grid;
        place-items: center;
        font-size: 0;
        color: transparent;
        flex-shrink: 0;
        box-shadow: inset 0 6px 14px rgba(255, 255, 255, 0.8),
          inset 0 -10px 16px rgba(0, 0, 0, 0.08), 0 12px 32px rgba(0, 0, 0, 0.2),
          0 0 0 2px rgba(255, 255, 255, 0.7);
      }

      .card .icon::after {
        content: "";
        position: absolute;
        inset: 10%;
        border-radius: 50%;
        background: radial-gradient(
          circle at 30% 30%,
          rgba(255, 255, 255, 0.7),
          rgba(255, 255, 255, 0)
        );
        pointer-events: none;
        filter: blur(1px);
      }

      .card .abbr {
        font-weight: 800;
        font-size: 1.15rem;
        color: rgba(0, 0, 0, 0.65);
        letter-spacing: 0.04em;
        opacity: 0.5;
      }

      .card .desc {
        display: none;
      }

      .progress {
        margin-top: 10px;
        background: rgba(0, 0, 0, 0.24);
        border-radius: 14px;
        height: 22px;
        overflow: hidden;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
        position: relative;
      }

      .progress-bar {
        height: 100%;
        border-radius: inherit;
        width: 0%;
        position: relative;
        overflow: hidden;
        isolation: isolate;
        background: var(--bar-base, #b32d2d);
        box-shadow: 0 0 12px var(--bar-glow, rgba(239, 107, 107, 0.8));
        background-image: linear-gradient(
            135deg,
            rgba(255, 255, 255, 0.18),
            rgba(255, 255, 255, 0.08)
          ),
          repeating-linear-gradient(
            45deg,
            rgba(255, 255, 255, 0.16) 0,
            rgba(255, 255, 255, 0.16) 12px,
            transparent 12px,
            transparent 24px
          );
        background-size: auto, 28px 28px;
        animation: stripeMove 2.25s linear infinite;
      }

      .progress-value {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        padding-right: 10px;
        font-weight: 800;
        font-size: 0.9rem;
        color: #f8fbff;
        text-shadow: 0 1px 4px rgba(0, 0, 0, 0.35);
        pointer-events: none;
      }

      .progress-label {
        display: none;
      }

      .progress-inline {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 6px;
      }

      .card::before {
        content: "";
        position: absolute;
        inset: -30% 30% 60% -40%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.25),
          transparent 55%
        );
        opacity: 0.6;
        transform: rotate(8deg);
        pointer-events: none;
      }

      .card.fph {
        background: linear-gradient(
          145deg,
          rgba(255, 179, 179, 0.95),
          rgba(238, 90, 90, 0.95)
        );
        border: 1px solid rgba(192, 64, 64, 0.45);
      }
      .card.fped {
        background: linear-gradient(
          145deg,
          rgb(246, 205, 169),
          rgb(247, 143, 39)
        );
        border: 1px solid rgba(212, 130, 48, 0.65);
      }
      .card.pdezv {
        background: linear-gradient(
          145deg,
          rgba(216, 223, 182, 0.95),
          rgba(130, 142, 64, 0.95)
        );
        border: 1px solid rgba(143, 153, 88, 0.45);
      }
      .card.phed {
        background: linear-gradient(
          145deg,
          rgba(255, 197, 230, 0.92),
          rgba(245, 105, 186, 0.94)
        );
        border: 1px solid rgba(193, 67, 140, 0.35);
      }
      .card.pedcom {
        background: linear-gradient(
          145deg,
          rgba(231, 205, 253, 0.95),
          rgba(167, 108, 230, 0.96)
        );
        border: 1px solid rgba(141, 124, 245, 0.4);
      }
      .card.lr {
        background: linear-gradient(
          145deg,
          rgba(176, 225, 255, 0.92),
          rgba(61, 134, 223, 0.96)
        );
        border: 1px solid rgba(54, 121, 203, 0.38);
      }

      .card.fph .progress-bar {
        --bar-base: #b32d2d;
        --bar-glow: rgba(239, 107, 107, 1);
      }
      .card.fph h3 {
        color: #6d1616;
      }
      .card.fped .progress-bar {
        --bar-base: #a85b00;
        --bar-glow: rgba(226, 141, 26, 1);
      }
      .card.fped h3 {
        color: #6b3a00;
      }
      .card.pdezv .progress-bar {
        --bar-base: #8a9152;
        --bar-glow: rgba(190, 200, 130, 1);
      }
      .card.pdezv h3 {
        color: #42471c;
      }
      .card.phed .progress-bar {
        --bar-base: #b02672;
        --bar-glow: rgba(223, 95, 168, 1);
      }
      .card.phed h3 {
        color: #6f1847;
      }
      .card.pedcom .progress-bar {
        --bar-base: #4636ad;
        --bar-glow: rgba(123, 107, 240, 1);
      }
      .card.pedcom h3 {
        color: #2e2474;
      }
      .card.lr .progress-bar {
        --bar-base: #1e65c5;
        --bar-glow: rgba(77, 141, 240, 1);
      }
      .card.lr h3 {
        color: #15417c;
      }

      .card.completed {
        background: radial-gradient(
            circle at 35% 25%,
            rgba(255, 255, 255, 0.78),
            rgba(255, 255, 255, 0.12) 58%
          ),
          linear-gradient(145deg, #eccd6f, #cbab33);
        border: 1px solid rgba(214, 160, 58, 0.7);
        box-shadow: 0 26px 70px rgba(210, 160, 68, 0.35),
          inset 0 1px 0 rgba(255, 255, 255, 0.35);
        animation: goldGlow 6.8s ease-in-out infinite;
      }

      .card.completed .progress {
        background: rgba(88, 56, 12, 0.2);
        box-shadow: inset 0 2px 6px rgba(36, 24, 4, 0.35),
          0 0 18px rgba(212, 170, 90, 0.45),
          inset 0 1px 0 rgba(255, 255, 255, 0.25);
      }

      .card.completed .progress-bar,
      .card.completed .progress-bar.trophy {
        --bar-base: #d4ba46;
        --bar-glow: rgba(235, 182, 86, 0.95);
        background: linear-gradient(135deg, #f9d677, #f1b24a);
        box-shadow: inset 0 2px 0 rgba(255, 255, 255, 0.45),
          inset 0 -6px 10px rgba(120, 78, 6, 0.35),
          0 0 20px rgba(225, 168, 70, 0.7);
        animation: stripeMove 2.25s linear infinite,
          goldGlow 6.8s ease-in-out infinite;
      }

      .card.completed .progress-bar::before {
        content: "";
        position: absolute;
        inset: 2px 6px auto 6px;
        height: 38%;
        border-radius: 999px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.7),
          rgba(255, 255, 255, 0)
        );
        opacity: 0.85;
        pointer-events: none;
      }

      .card.completed h3,
      .card.completed .progress-value {
        color: #fff6da;
        text-shadow: none;
        opacity: 0.9;
      }

      .card.completed::after {
        animation: shineSweep 6.8s ease-in-out infinite;
      }

      .card.completed:hover::after {
        animation: shineSweep 6.8s ease-in-out infinite, shineHover 0.85s ease;
      }

      /* Subject icons (inline svg as data URI) */
      .icon-brain {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128' fill='none' stroke='%23f26a6a' stroke-width='8.4' stroke-linecap='round' stroke-linejoin='round'><g transform='translate(-2.5 0) scale(1.04 1)'><path d='M64 14c-13 0-24 10.8-24 24v3c-11 2.6-19 12.1-19 23.2 0 11.9 9 21.8 20.5 23.4V90c0 12 9.5 22 22 22h0c12.5 0 22-10 22-22v-2.4C96 86 105 76.1 105 64.2c0-11.1-8-20.6-19-23.2v-3C86 24.8 77 14 64 14Z'/><path d='M64 30v68'/><path d='M52 40c-7 4-12 11-12 19s5 15 12 19'/><path d='M76 40c7 4 12 11 12 19s-5 15-12 19'/><path d='M52 56c-4 3-6 7-6 11s2 8 6 11'/><path d='M76 56c4 3 6 7 6 11s-2 8-6 11'/></g></svg>");
        background-size: 70% !important;
        background-position: calc(50% + 1px) calc(50% + 0px) !important;
      }
      .icon-cap {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%23d63d8c' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M12 44l48-16 48 16-48 16-48-16z'/><path d='M36 54v18c0 9 11 16 24 16s24-7 24-16V54' stroke-width='7'/><path d='M96 52v18' stroke-width='7'/><circle cx='96' cy='78' r='6' fill='%23d63d8c'/></svg>");
      }
      .icon-plant {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%237b8038' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M60 98V54'/><path d='M60 70c-18 0-32-12-32-28 12 0 21 4 32 12 11-8 20-12 32-12 0 16-14 28-32 28z'/><path d='M60 54c-10 0-18-8-18-18 8 0 12 2 18 6 6-4 10-6 18-6 0 10-8 18-18 18z'/></svg>");
      }
      .icon-stack {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%23c58a2a' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M20 34l32-10 48 14-32 10-48-14z'/><path d='M20 54l32-10 48 14-32 10-48-14z'/><path d='M20 74l32-10 48 14-32 10-48-14z'/></svg>");
      }
      .icon-book {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%2347a2ff' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M60 30v60'/><path d='M60 30c-10-6-22-8-34-6v60c12-2 24 0 34 6'/><path d='M60 30c10-6 22-8 34-6v60c-12-2-24 0-34 6'/></svg>");
      }
      .icon-bubble {
        --icon-bg: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120' fill='none' stroke='%237b6bf0' stroke-width='8' stroke-linecap='round' stroke-linejoin='round'><path d='M60 24c-22 0-40 14-40 32 0 18 18 32 40 32 4 0 8-0 12-1l18 9-4-14c9-6 14-15 14-26 0-18-18-32-40-32z'/></svg>");
      }

      .card .progress-bar {
        filter: saturate(1.35) brightness(1.1);
        box-shadow: 0 0 20px var(--bar-glow, rgba(239, 107, 107, 0.9));
        background-image: linear-gradient(
            135deg,
            rgba(255, 255, 255, 0.26),
            rgba(255, 255, 255, 0.12)
          ),
          repeating-linear-gradient(
            45deg,
            rgba(255, 255, 255, 0.22) 0,
            rgba(255, 255, 255, 0.22) 12px,
            transparent 12px,
            transparent 24px
          );
      }

      @keyframes bubble {
        0% {
          transform: translateX(-12%) translateY(6%) scale(1);
        }
        50% {
          transform: translateX(12%) translateY(-6%) scale(1.1);
        }
        100% {
          transform: translateX(-12%) translateY(6%) scale(1);
        }
      }

      @keyframes bubbleReverse {
        0% {
          transform: translateX(10%) translateY(-4%) scale(1);
        }
        50% {
          transform: translateX(-10%) translateY(4%) scale(1.08);
        }
        100% {
          transform: translateX(10%) translateY(-4%) scale(1);
        }
      }

      @keyframes stripeMove {
        from {
          background-position: 0 0, 0 0;
        }
        to {
          background-position: 0 0, 56px 0;
        }
      }

      @keyframes modalLift {
        0% {
          transform: translateY(12px) scale(0.96) rotate(-0.18deg);
          opacity: 0;
          box-shadow: 0 14px 40px rgba(0, 0, 0, 0.25);
        }
        60% {
          transform: translateY(-4px) scale(1.01) rotate(0deg);
          opacity: 1;
          box-shadow: 0 22px 58px rgba(0, 0, 0, 0.3);
        }
        100% {
          transform: translateY(0) scale(1) rotate(0deg);
          opacity: 1;
          box-shadow: var(--shadow);
        }
      }

      @keyframes modalClose {
        0% {
          transform: translateY(0) scale(1) rotate(0deg);
          opacity: 1;
          box-shadow: var(--shadow);
        }
        100% {
          transform: translateY(10px) scale(0.95) rotate(-0.1deg);
          opacity: 0;
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
      }

      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.55);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
        z-index: 10;
      }

      .overlay.show {
        display: flex;
      }

      .modal {
        background: #0f172a;
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 20px;
        padding: 22px;
        width: min(1050px, 100%);
        box-shadow: var(--shadow);
        color: var(--text);
        position: relative;
        max-height: 92vh;
        overflow-y: auto;
        scroll-behavior: smooth;
        transform: translateY(12px) scale(0.96) rotate(-0.1deg);
        opacity: 0;
        will-change: transform, opacity;
      }

      .overlay.show .modal {
        animation: modalLift 0.55s cubic-bezier(0.22, 1, 0.36, 1);
        transform: translateY(0) scale(1) rotate(0deg);
        opacity: 1;
      }

      .modal.closing {
        animation: modalClose 0.32s cubic-bezier(0.33, 1, 0.68, 1) forwards;
      }

      .modal h3 {
        font-size: 1.3rem;
        margin-bottom: 6px;
      }
      .modal p {
        color: var(--muted);
        margin-bottom: 8px;
      }
      .modal .close {
        position: absolute;
        top: 12px;
        right: 12px;
        background: rgba(255, 255, 255, 0.08);
        border: none;
        color: #fff;
        border-radius: 50%;
        width: 34px;
        height: 34px;
        font-size: 1rem;
        cursor: pointer;
      }

      .topic {
        padding: 16px 14px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.04);
        margin-bottom: 12px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
        width: 100%;
      }

      .topic strong {
        color: #fff;
        display: block;
      }
      .topic .meta {
        color: var(--muted);
        font-size: 0.9rem;
      }

      .topic .progress {
        margin: 6px 0 0 0;
        height: 22px;
      }

      .pill {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 10px;
        padding: 10px 14px;
        font-size: 0.98rem;
        color: #fff;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        justify-content: center;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.18);
      }

      .pill-course {
        display: grid;
        grid-template-columns: auto 1fr auto;
        align-items: center;
        gap: 10px;
        padding: 16px 16px;
        width: 100%;
        margin-right: 6px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2),
          0 12px 28px rgba(0, 0, 0, 0.25);
      }

      .pill-course .pill-percent {
        padding: 6px 10px;
        border-radius: 12px;
        font-weight: 800;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2),
          0 0 12px rgba(255, 255, 255, 0.18);
        border: 1px solid rgba(255, 255, 255, 0.28);
      }

      .pill-percent.red {
        background: linear-gradient(
          120deg,
          rgba(248, 113, 113, 0.22),
          rgba(248, 113, 113, 0.32)
        );
        color: #fee2e2;
      }
      .pill-percent.orange {
        background: linear-gradient(
          120deg,
          rgba(251, 146, 60, 0.22),
          rgba(251, 146, 60, 0.32)
        );
        color: #fff7ed;
      }
      .pill-percent.yellow {
        background: linear-gradient(
          120deg,
          rgba(250, 204, 21, 0.22),
          rgba(250, 204, 21, 0.32)
        );
        color: #fefce8;
      }
      .pill-percent.green {
        background: linear-gradient(
          120deg,
          rgba(52, 211, 153, 0.22),
          rgba(52, 211, 153, 0.32)
        );
        color: #ecfdf3;
      }

      .pill-percent {
        color: #fff;
      }

      .quiz-btn,
      .pdf-link {
        background: linear-gradient(135deg, #f8fafc, #e2e8f0);
        color: #0f172a;
        border: 1px solid rgba(15, 23, 42, 0.08);
        padding: 12px 16px;
        border-radius: 14px;
        font-weight: 800;
        letter-spacing: 0.01em;
        cursor: pointer;
        transition: transform 0.18s ease, box-shadow 0.18s ease,
          filter 0.18s ease;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        box-shadow: 0 10px 28px rgba(0, 0, 0, 0.24),
          inset 0 1px 0 rgba(255, 255, 255, 0.6);
        text-transform: uppercase;
      }

      .quiz-btn:hover,
      .pdf-link:hover {
        transform: translateY(-1px) scale(1.01);
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.26);
        filter: brightness(1.02);
      }
      .quiz-btn:active,
      .pdf-link:active {
        transform: translateY(0);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.2);
      }

      .quiz {
        margin-top: 14px;
        padding: 16px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.07);
      }

      .quiz-question {
        position: relative;
        padding-left: 46px;
      }

      .quiz h4 {
        margin-top: 12px;
        margin-bottom: 16px;
        font-size: 1.2rem;
        line-height: 1.6;
      }
      .quiz label {
        display: block;
        margin-bottom: 8px;
        cursor: pointer;
      }
      .quiz input {
        margin-right: 10px;
        width: 20px;
        height: 20px;
        vertical-align: middle;
      }

      .choice {
        padding: 8px 10px;
        border-radius: 10px;
        transition: background 0.2s ease, transform 0.2s ease;
        display: flex;
        align-items: center;
        gap: 10px;
        line-height: 30px;
      }

      .choice:hover {
        background: rgba(255, 255, 255, 0.04);
        transform: translateX(2px);
      }

      .choice.correct {
        background: rgba(34, 197, 94, 0.18);
        border: 1px solid rgba(34, 197, 94, 0.4);
      }

      .choice.incorrect {
        background: rgba(239, 68, 68, 0.16);
        border: 1px solid rgba(239, 68, 68, 0.3);
      }

      .quiz-sep {
        border: none;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        margin: 32px 0;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.12);
      }

      .quiz-question::before {
        content: "?";
        position: absolute;
        left: 0;
        top: -4px;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.12);
        color: #d1d5db;
        display: grid;
        place-items: center;
        font-weight: 800;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.25);
      }

      .quiz-question.q-correct::before {
        content: "✓";
        background: rgba(16, 185, 129, 0.22);
        color: #34d399;
        border: 1px solid rgba(52, 211, 153, 0.6);
      }

      .quiz-question.q-incorrect::before {
        content: "✕";
        background: rgba(239, 68, 68, 0.18);
        color: #f87171;
        border: 1px solid rgba(248, 113, 113, 0.6);
      }

      .toggle-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 12px 18px;
        border-radius: 999px;
        text-transform: uppercase;
        font-weight: 900;
        letter-spacing: 0.04em;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.95),
          rgba(255, 255, 255, 0.82)
        );
        color: #0f172a;
        border: 1px solid rgba(15, 23, 42, 0.08);
        box-shadow: 0 12px 28px rgba(0, 0, 0, 0.22),
          inset 0 1px 0 rgba(255, 255, 255, 0.7);
      }

      .chevron {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.15rem;
        font-weight: 900;
        line-height: 1;
        transition: transform 0.3s ease;
        transform-origin: 50% 50%;
        width: 18px;
        height: 18px;
        text-align: center;
      }

      .collapsible {
        max-height: 0;
        overflow: hidden;
        opacity: 0;
        transform: translateY(-6px);
        transition: max-height 0.35s ease, opacity 0.35s ease,
          transform 0.35s ease;
        pointer-events: none;
      }

      .collapsible.expanded {
        max-height: none;
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
        margin-top: 6px;
        overflow: visible;
      }

      #quizPanel {
        transform: scale(0.97);
        opacity: 0;
        transition: transform 0.35s ease, opacity 0.35s ease;
      }

      #quizPanel.show {
        transform: scale(1);
        opacity: 1;
      }

      #quizPanel.exit {
        transform: scale(0.95);
        opacity: 0;
      }

      #quizPanel.complete {
        animation: quizCelebrate 0.65s ease;
      }

      .confetti {
        position: absolute;
        width: 8px;
        height: 12px;
        background: #ffb703;
        opacity: 0.9;
        border-radius: 2px;
        animation: confettiFall 1s ease-out forwards;
        pointer-events: none;
      }

      @keyframes quizCelebrate {
        0% {
          transform: scale(0.97);
          opacity: 0.6;
        }
        50% {
          transform: scale(1.05);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      @keyframes confettiFall {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 1;
        }
        100% {
          transform: translateY(140px) rotate(240deg);
          opacity: 0;
        }
      }

      .feedback {
        margin-top: 10px;
        padding: 10px 12px;
        border-radius: 10px;
        font-weight: 700;
        display: none;
      }

      .feedback.success {
        display: block;
        background: rgba(16, 185, 129, 0.15);
        color: #a7f3d0;
        border: 1px solid rgba(16, 185, 129, 0.3);
      }

      .feedback.info {
        display: block;
        background: rgba(255, 255, 255, 0.07);
        color: #e5e7eb;
        border: 1px solid rgba(255, 255, 255, 0.12);
      }

      .empty {
        padding: 14px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.04);
        color: var(--muted);
        text-align: center;
      }

      .capitol {
        padding: 16px;
        border-radius: 16px;
        background: linear-gradient(
          150deg,
          rgba(255, 255, 255, 0.04),
          rgba(13, 17, 23, 0.6)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        margin-bottom: 24px;
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      .capitol-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 12px;
        flex-wrap: wrap;
      }

      .capitol-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
        flex: 0;
      }

      .subcap {
        padding: 12px;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
        margin: 12px 0 0 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: stretch;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
      }

      .subcap-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        width: 100%;
      }

      .subcap-title {
        font-weight: 800;
        color: #f8fafc;
        display: flex;
        align-items: center;
        gap: 8px;
        margin: 0;
      }

      .subcap-status {
        width: 24px;
        height: 24px;
        min-width: 24px;
        min-height: 24px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.3);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-weight: 900;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.65);
        background: transparent;
        transition: all 0.2s ease;
        flex-shrink: 0;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
      }

      .subcap-status.done {
        background: rgba(52, 211, 153, 0.15);
        border-color: rgba(52, 211, 153, 0.8);
        color: #34d399;
        box-shadow: 0 0 12px rgba(52, 211, 153, 0.35);
      }

      .subcap-quiz-list .topic {
        position: relative;
        display: block;
        padding-right: 16px;
      }

      .subcap-quiz-list .topic button {
        position: absolute;
        right: 16px;
        top: 16px;
      }

      .subcap-quiz-list .topic .progress {
        margin-top: 12px;
        width: 100%;
      }

      .hidden {
        display: none !important;
      }

      #capitoleContainer,
      #topicsContainer {
        margin-top: 36px;
      }

      .completed-highlight {
        animation: completedPulse 1.8s ease;
      }

      .emoji-pop {
        position: absolute;
        font-size: 1.5rem;
        animation: emojiRise 0.9s ease forwards;
        pointer-events: none;
      }

      .quiz-actions {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-top: 12px;
      }

      .quiz-btn.primary {
        flex: 1;
        background: linear-gradient(135deg, #22d3ee, #4f46e5);
        color: #f8fafc;
        border: 1px solid rgba(79, 70, 229, 0.4);
        box-shadow: 0 14px 30px rgba(79, 70, 229, 0.35);
      }

      .quiz-btn.secondary {
        background: rgba(255, 255, 255, 0.08);
        color: #e6edf3;
        border: 1px solid rgba(255, 255, 255, 0.16);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
      }

      .quiz-btn.split {
        flex: 1;
        justify-content: center;
      }

      @keyframes completedPulse {
        0% {
          box-shadow: 0 0 0 0 rgba(107, 232, 247, 0.4);
        }
        50% {
          box-shadow: 0 0 0 10px rgba(107, 232, 247, 0.1);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(107, 232, 247, 0);
        }
      }

      @keyframes emojiRise {
        0% {
          transform: translateY(10px) scale(0.85);
          opacity: 0;
        }
        60% {
          transform: translateY(-10px) scale(1.1);
          opacity: 1;
        }
        100% {
          transform: translateY(-20px) scale(1);
          opacity: 0;
        }
      }

      @media (max-width: 600px) {
        body {
          padding: 0px;
        }

        .intro h1 {
          font-size: 2rem;
        }
        .map {
          padding: 18px;
        }
        .modal {
          padding: 18px 18px 60px 18px;
        }
        .capitol-header {
          flex-direction: column;
          align-items: stretch;
          gap: 10px;
          width: 100%;
        }
        .capitol-actions {
          width: 100%;
          justify-content: flex-start;
        }
        .capitol-actions .quiz-btn {
          width: 100%;
          justify-content: center;
        }
        .pill-course {
          width: 100%;
          margin-bottom: 4px;
        }
        .subcap-header {
          flex-direction: column;
          align-items: flex-start;
        }
        .subcap button {
          width: 100%;
          justify-content: center;
        }
        .subcap-quiz-list .topic {
          padding-right: 16px;
        }
        .subcap-quiz-list .topic button {
          position: static;
          width: 100%;
          margin-top: 8px;
        }

        /* Deck flashcards */
        .deck-row {
          display: flex;
          flex-wrap: wrap;
          gap: 12px;
          margin-top: 16px;
          align-items: stretch;
        }

        .deck-box {
          flex: 1 1 320px;
          position: relative;
          overflow: hidden;
        }

        .deck-box.deck-primary {
          background: rgba(255, 255, 255, 0.03);
          border: 1px solid rgba(255, 255, 255, 0.08);
          border-radius: 14px;
          padding: 14px;
          box-shadow: 0 12px 28px rgba(0, 0, 0, 0.25),
            inset 0 1px 0 rgba(255, 255, 255, 0.15);
          display: grid;
          gap: 10px;
        }

        .deck-front-area {
          display: grid;
          gap: 10px;
          justify-items: center;
        }

        .deck-term {
          font-weight: 800;
          font-size: 1.1rem;
          text-align: center;
        }

        .deck-score {
          text-align: center;
          color: #cbd5e1;
          font-weight: 700;
        }

        .deck-score-pill {
          display: inline-flex;
          align-items: center;
          gap: 6px;
          padding: 6px 12px;
          border-radius: 999px;
          background: rgba(255, 255, 255, 0.08);
          border: 1px solid rgba(255, 255, 255, 0.12);
          font-weight: 800;
        }

        .deck-header {
          display: flex;
          align-items: center;
          justify-content: space-between;
          gap: 10px;
        }

        .deck-title {
          font-weight: 800;
          color: #f8fafc;
          letter-spacing: 0.01em;
        }

        .deck-cards {
          display: grid;
          gap: 12px;
          padding: 40px;
        }

        .deck-meta {
          display: grid;
          gap: 6px;
          justify-items: end;
        }

        .deck-card {
          background: rgba(255, 255, 255, 0.04);
          border: 1px solid rgba(255, 255, 255, 0.1);
          border-radius: 12px;
          padding: 14px;
          display: grid;
          gap: 10px;
        }

        .deck-card.static {
          background: linear-gradient(
            145deg,
            rgba(255, 255, 255, 0.06),
            rgba(255, 255, 255, 0.02)
          );
          border: 1px solid rgba(255, 255, 255, 0.12);
          box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12),
            0 10px 24px rgba(0, 0, 0, 0.28);
        }

        .deck-card.feature {
          background: linear-gradient(
            150deg,
            rgba(255, 255, 255, 0.08),
            rgba(15, 23, 42, 0.4)
          );
          border: 1px solid rgba(255, 255, 255, 0.14);
          box-shadow: 0 18px 46px rgba(0, 0, 0, 0.35),
            inset 0 1px 0 rgba(255, 255, 255, 0.18);
          padding: 0px;
        }

        .deck-chip {
          display: inline-flex;
          align-items: center;
          gap: 6px;
          background: rgba(34, 211, 238, 0.16);
          border: 1px solid rgba(34, 211, 238, 0.4);
          color: #a5f3fc;
          border-radius: 999px;
          padding: 6px 10px;
          font-weight: 800;
          letter-spacing: 0.01em;
          width: fit-content;
        }

        .deck-front-label,
        .deck-back-label {
          font-size: 0.9rem;
          letter-spacing: 0.02em;
          text-transform: uppercase;
          color: #cbd5e1;
        }

        .deck-front {
          font-weight: 800;
          font-size: 1.05rem;
          color: #f8fafc;
        }

        .deck-back {
          color: #e6edf3;
          font-size: 0.98rem;
          line-height: 1.55;
        }

        .deck-back br {
          display: block;
          margin-top: 6px;
          content: "";
        }

        .deck-card.completed {
          opacity: 0.85;
        }

        .deck-counts {
          margin-top: 10px;
          display: flex;
          gap: 8px;
          align-items: center;
        }

        .deck-dot {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          min-width: 36px;
          padding: 6px 10px;
          border-radius: 999px;
          font-weight: 800;
          color: #0f172a;
          box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
        .deck-dot.red {
          background: #f87171;
          color: #1f2937;
        }
        .deck-dot.yellow {
          background: #facc15;
          color: #1f2937;
        }
        .deck-dot.green {
          background: #22c55e;
          color: #0b1a10;
        }

        /* Flip effect */
        .flip-wrap {
          perspective: 1200px;
        }
        .flip-card {
          position: relative;
          width: 100%;
          min-height: 200px;
          transform-style: preserve-3d;
          transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
        }
        .flip-face {
          position: absolute;
          inset: 0;
          backface-visibility: hidden;
        }
        .flip-back {
          transform: rotateY(180deg);
        }
        .deck-box.revealed .flip-card {
          transform: rotateY(180deg);
        }

        .quiz-question {
          padding-left: 0;
          padding-top: 10px;
        }

        .quiz-question::before {
          position: relative;
          left: 0;
          top: 0;
          margin-bottom: 8px;
        }

        .modal {
          width: 100vw;
          height: 100vh;
          max-height: 100vh;
          border-radius: 0;
          padding: 18px 18px 60px 18px;
        }

        .overlay {
          padding: 0;
        }
      }

      .tip {
        position: relative;
        cursor: default;
        color: #e6f2ff;
        text-decoration: none;
        border-bottom: none;
        padding-bottom: 4px;
      }

      /* Pointer doar în context de quiz */
      .quiz .tip,
      #quizPanelContent .tip {
        cursor: pointer;
      }

      .tip:not(.help-tip) {
        background-image: linear-gradient(to right, #315565, #2a3549);
        background-position: 0 100%;
        background-repeat: no-repeat;
        background-size: calc(100% - 28px) 2px;
      }

      .tip.tip-long:not(.help-tip) {
      }

      .tooltip-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        margin-left: 6px;
        margin-right: 6px;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.18);
        background-image: url("Assets/light-bulb.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: 72%;
        filter: saturate(0) brightness(0.8);
        opacity: 0.65;
        vertical-align: middle;
        cursor: default;
        flex-shrink: 0;
      }

      .help-tip {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        margin-left: 8px;
        border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.18);
        background-image: url("Assets/light-bulb.png");
        background-position: center;
        background-repeat: no-repeat;
        background-size: 72%;
        color: transparent;
        font-weight: 800;
        font-size: 0.8rem;
        line-height: 1;
        filter: saturate(0) brightness(0.8);
        opacity: 0.65;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12),
          0 3px 10px rgba(0, 0, 0, 0.2);
        vertical-align: middle;
        transition: transform 0.12s ease, box-shadow 0.12s ease;
      }

      .help-tip:hover {
        transform: translateY(-1px);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.15),
          0 6px 16px rgba(0, 0, 0, 0.24);
      }

      /* Desktop / tablet */
      .tip .tooltip-box {
        position: absolute;
        bottom: -180%;
        left: 50%;
        transform: translateX(-50%);
        background: #111;
        color: #fff;
        padding: 14px 16px;
        border-radius: 10px;
        width: 250px;
        max-width: 90vw;
        font-size: 0.9em;
        line-height: 1.45;
        text-align: justify;
        text-justify: inter-word;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        opacity: 0;
        pointer-events: none;
        padding: 32px;
        z-index: 9999;
        display: none !important;
        visibility: hidden !important;
      }

      .tooltip-floating {
        position: fixed;
        background: #111;
        color: #fff;
        padding: 16px 24px;
        border-radius: 10px;
        width: 400px;
        max-width: 90vw;
        font-size: 0.9em;
        line-height: 1.45;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        z-index: 12000;
        pointer-events: none;
      }

      /* Show tooltip on hover / tap (disabled – handled by floating tooltip) */
      .tip:hover .tooltip-box {
        display: none !important;
        opacity: 0 !important;
        visibility: hidden !important;
      }

      /* Mobil: ecrane înguste */
      @media (max-width: 768px) {
        .tip .tooltip-box {
          display: none !important;
        }

        .deck-box {
          padding: 0 !important;
          border-radius: 12px;
        }

        .deck-cards {
          padding: 0 0 32px !important;
          gap: 14px !important;
        }

        .deck-card.feature {
          padding: 12px !important;
          gap: 18px !important;
          min-height: 600px;
        }

        .deck-header {
          flex-direction: column;
          align-items: flex-start;
          width: 100%;
          gap: 8px;
        }

        .deck-header > * {
          width: 100%;
        }

        .deck-score-pill {
          justify-content: flex-start;
        }

        .flip-shell {
          min-height: 600px !important;
        }

        .flip-face {
          padding: 12px !important;
          gap: 12px !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <!--
      <section class="intro" id="intro">
        <h1>Bun venit!</h1>
        <p>
          Apasă butonul și intră pe harta celor 6 materii. Progresul pornește de
          la 0%.
        </p>
        <button class="start-btn" id="startBtn">Începe călătoria ↗</button>
      </section>
      -->

      <section class="map visible" id="map">
        <h2>
          Proiect personal în cadrul UNIVERSITĂȚII TRANSILVANIA, PIPP, Anul 1,
          Semestrul 1
          <span
            class="tip help-tip"
            aria-label="Disclaimer"
            data-tip-id="legal-disclaimer"
          >
            ?
            <span class="tooltip-box">
              Informațiile prezentate în această aplicație sunt generate automat
              prin sintetizarea suportului de curs cu ajutorul inteligenței
              artificiale și pot conține erori, omisiuni sau imprecizii.
              Conținutul are un
              <strong>scop exclusiv educațional și orientativ</strong>, iar
              <strong>acuratețea și completitudinea sa nu sunt garantate</strong
              >. <br /><br />

              <strong>
                Aplicația nu înlocuiește materialele oficiale de curs sau
                evaluările academice.
              </strong>
              Dezvoltatorul aplicației
              <strong>nu își asumă răspunderea</strong> pentru eventuale erori,
              omisiuni sau interpretări rezultate din utilizarea informațiilor.
              <br /><br />

              <strong>
                Accesul la aplicație și progresul utilizatorului pot fi
                suspendate sau restricționate, parțial sau total, fără
                notificare prealabilă.
              </strong>
            </span>
          </span>
        </h2>
        <div class="grid">
          <article class="card fph" data-id="fph">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-brain"></span>
                <span class="abbr">FPH</span>
              </div>
              <div>
                <h3>Fundamentele Psihologiei</h3>
                <p class="desc">
                  Punct de start pentru înțelegerea psihologiei.
                </p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
          <article class="card fped" data-id="fped">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-stack"></span>
                <span class="abbr">FPED</span>
              </div>
              <div>
                <h3>Fundamentele Pedagogiei</h3>
                <p class="desc">
                  Traseu despre baza pedagogiei și metode didactice.
                </p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
          <article class="card pdezv" data-id="pdezv">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-plant"></span>
                <span class="abbr">PDEZV</span>
              </div>
              <div>
                <h3>Psihologia Dezvoltării</h3>
                <p class="desc">Explorează etapele dezvoltării psihologice.</p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
          <article class="card phed" data-id="phed">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-cap"></span>
                <span class="abbr">PHEd</span>
              </div>
              <div>
                <h3>Psihologia Educației</h3>
                <p class="desc">Focus pe procesele psihologice din educație.</p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
          <article class="card pedcom" data-id="pedcom">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-bubble"></span>
                <span class="abbr">PEDCOM</span>
              </div>
              <div>
                <h3>Pedagogia comunicării</h3>
                <p class="desc">
                  Zone despre comunicare și relația profesor-elev.
                </p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
          <article class="card lr" data-id="lr">
            <div class="card-header">
              <div class="icon-stack">
                <span class="icon icon-book"></span>
                <span class="abbr">LR</span>
              </div>
              <div>
                <h3>Limba Română</h3>
                <p class="desc">
                  Explorări de text, gramatică și analiză literară.
                </p>
              </div>
            </div>
            <div class="progress"><div class="progress-bar"></div></div>
            <div class="progress-label">Parcurs 0%</div>
          </article>
        </div>
        <div class="support-box">
          <div class="support-hint">Ai întrebări sau sugestii?</div>
          <a
            class="whatsapp-btn"
            href="https://wa.me/40742804731"
            target="_blank"
            rel="noreferrer"
          >
            <span class="whatsapp-icon" aria-hidden="true">
              <svg viewBox="0 0 32 32" aria-hidden="true">
                <path
                  d="M16 3C9.4 3 4 8.4 4 15c0 2.2.6 4.3 1.6 6.1L4 29l8.1-2.1C13 27.6 14.5 28 16 28c6.6 0 12-5.4 12-12S22.6 3 16 3Zm6.6 15.9c-.3.8-1.6 1.5-2.2 1.6-.6.1-1.3.1-2.1-.1-.5-.2-1.1-.4-1.9-.7-3.4-1.5-5.6-4.9-5.8-5.1-.2-.2-1.4-1.8-1.4-3.5 0-1.7.9-2.5 1.2-2.8.3-.3.7-.4.9-.4.2 0 .5 0 .7.1.2 0 .5-.1.8.6.3.7.9 2.3 1 2.5.1.2.1.4 0 .6-.1.2-.2.3-.3.5-.2.2-.3.4-.5.6-.2.2-.3.4-.2.7.2.3.8 1.3 1.7 2.1 1.2 1 2.2 1.4 2.5 1.5.3.2.5.1.7-.1.2-.2.8-1 1.1-1.3.2-.4.5-.3.8-.2.3.1 2 .9 2.3 1.1.3.1.5.3.6.4.1.1.1.8-.1 1.6Z"
                />
              </svg>
            </span>
            <span>Contactează dezvoltatorul aplicației</span>
          </a>
        </div>
      </section>
    </div>

    <div class="overlay" id="detailOverlay">
      <div class="modal">
        <button class="close" id="closeDetail">×</button>
        <h3 id="detailTitle"></h3>
        <p id="detailDesc" class="hidden"></p>
        <div
          class="progress-inline hidden"
          id="subjectProgressWrap"
          style="margin: 12px 0 16px 0"
        >
          <div class="progress" style="flex: 1; margin-top: 0">
            <div class="progress-bar" id="subjectProgressBar"></div>
          </div>
          <div class="progress-label" id="subjectProgress">Parcurs 0%</div>
          <a
            class="pdf-link"
            id="pdfLink"
            href="#"
            target="_blank"
            rel="noreferrer"
            >Deschide PDF</a
          >
          <a class="pdf-link hidden" id="backToList" href="javascript:void(0)"
            >← Înapoi</a
          >
        </div>
        <div id="capitoleContainer"></div>
        <div id="topicsContainer" class="hidden"></div>
        <div id="quizPanel" class="hidden">
          <h4 id="quizPanelTitle" style="margin-bottom: 10px"></h4>
          <div class="quiz" id="quizPanelContent"></div>
          <div id="quizPanelFeedback" class="feedback"></div>
          <div class="quiz-actions">
            <button class="quiz-btn secondary" id="quizPanelBack" type="button">
              ← Înapoi
            </button>
            <button class="quiz-btn primary" id="quizPanelSubmit">
              Trimite răspunsul
            </button>
            <button
              class="quiz-btn secondary hidden"
              id="quizPanelRestart"
              type="button"
            >
              Reia QUIZul
            </button>
          </div>
        </div>
      </div>
    </div>

    <script src="fph.js"></script>
    <script src="fped.js"></script>
    <script src="phed.js"></script>
    <script>
      const subjects = [
        {
          id: "fph",
          name: "FPH (Fundamentele Psihologiei)",
          symbol: "🧠",
          pdf: "docs/fph.pdf",
          capitole: [],
          topics: [],
        },
        {
          id: "fped",
          name: "FPED (Fundamentele Pedagogiei)",
          symbol: "📚",
          pdf: "docs/fped.pdf",
          capitole: [],
          topics: [],
        },
        {
          id: "pdezv",
          name: "PDEZV (Psihologia Dezvoltării)",
          symbol: "🌱",
          pdf: "docs/pdezv.pdf",
          topics: [
            {
              id: "pdezv-t1",
              title: "Etape de dezvoltare",
              question: {
                text: "O etapă centrală la Piaget este:",
                options: [
                  "Operațiilor formale",
                  "Motivației extrinseci",
                  "Învățării sociale",
                ],
                answer: 0,
              },
            },
            {
              id: "pdezv-t2",
              title: "Atașament",
              question: {
                text: "Stilul de atașament securizant se caracterizează prin:",
                options: [
                  "Evitarea constantă a adultului",
                  "Confort la întoarcerea adultului",
                  "Indiferență totală",
                ],
                answer: 1,
              },
            },
          ],
        },
        {
          id: "phed",
          name: "PHEd (Psihologia Educației)",
          symbol: "🎓",
          pdf: "docs/phed.pdf",
          capitole: [],
          topics: [],
        },
        {
          id: "pedcom",
          name: "PedCom (Pedagogia comunicării)",
          symbol: "💬",
          pdf: "docs/pedcom.pdf",
          topics: [
            {
              id: "pedcom-t1",
              title: "Ascultare activă",
              question: {
                text: "Ascultarea activă presupune:",
                options: [
                  "Doar auzirea mesajului",
                  "Parafrazare și clarificare",
                  "Intervenții permanente",
                ],
                answer: 1,
              },
            },
            {
              id: "pedcom-t2",
              title: "Feedback eficient",
              question: {
                text: "Feedback-ul constructiv este de obicei:",
                options: [
                  "Specific și orientat spre soluție",
                  "General și ambiguu",
                  "Întotdeauna negativ",
                ],
                answer: 0,
              },
            },
          ],
        },
        {
          id: "lr",
          name: "Limba Română",
          symbol: "📖",
          pdf: "docs/lr.pdf",
          topics: [
            {
              id: "lr-t1",
              title: "Analiză de text",
              question: {
                text: "O analiză literară riguroasă include:",
                options: [
                  "Doar rezumatul textului",
                  "Temă, motive, structură și limbaj",
                  "Ignorarea contextului autorului",
                ],
                answer: 1,
              },
            },
            {
              id: "lr-t2",
              title: "Gramatică",
              question: {
                text: "Alege varianta corectă:",
                options: [
                  "Sunt sigur că voi reuși",
                  "Sunt sigur că voi reuși-voi",
                  "Sigur sunt că voi reuși",
                ],
                answer: 0,
              },
            },
          ],
        },
      ];

      const startBtn = document.getElementById("startBtn");
      const intro = document.getElementById("intro");
      const map = document.getElementById("map");
      const cards = document.querySelectorAll(".card");
      const detailOverlay = document.getElementById("detailOverlay");
      const closeDetail = document.getElementById("closeDetail");
      const detailTitle = document.getElementById("detailTitle");
      const detailDesc = document.getElementById("detailDesc");
      const pdfLink = document.getElementById("pdfLink");
      const topicsContainer = document.getElementById("topicsContainer");
      const capitoleContainer = document.getElementById("capitoleContainer");
      const subjectProgressLabel = document.getElementById("subjectProgress");
      const subjectProgressBar = document.getElementById("subjectProgressBar");
      const backToList = document.getElementById("backToList");
      const subjectProgressWrap = document.getElementById(
        "subjectProgressWrap"
      );
      const quizPanel = document.getElementById("quizPanel");
      const quizPanelTitle = document.getElementById("quizPanelTitle");
      const quizPanelContent = document.getElementById("quizPanelContent");
      const quizPanelFeedback = document.getElementById("quizPanelFeedback");
      const quizPanelSubmit = document.getElementById("quizPanelSubmit");
      const quizPanelRestart = document.getElementById("quizPanelRestart");
      const quizPanelBack = document.getElementById("quizPanelBack");

      let progressStore = loadProgress();
      let deckState = loadDeckState();

      function loadDeckState() {
        try {
          return JSON.parse(localStorage.getItem("deckStateV1")) || {};
        } catch (e) {
          return {};
        }
      }

      function saveDeckState() {
        localStorage.setItem("deckStateV1", JSON.stringify(deckState));
      }

      function getDeckCards(deck) {
        return deck?.cards ? deck.cards : [];
      }

      function splitBackContent(card) {
        const raw =
          typeof card.back === "string"
            ? card.back
            : card.back?.academic || card.back?.simple || "";
        const simpleRaw =
          typeof card.simple === "string" ? card.simple : card.back?.simple;
        let academic = raw;
        let simplified = simpleRaw || "";
        const marker = "🧠";
        if (!simplified && raw.includes(marker)) {
          const parts = raw.split(marker);
          academic = parts.shift()?.trim() || "";
          simplified = `${marker} ${parts.join(marker).trim()}`;
        }
        return {
          academic: academic || "Conținut indisponibil",
          simplified: simplified || "",
        };
      }

      function parseFrontParts(card) {
        const text = (card?.front || "").trim();
        const regex = /(Definește|Defineste)/i;
        const m = text.match(regex);
        if (!m) {
          return {
            context: "",
            main: text || "În curând",
            backTitle: text || "Răspuns",
          };
        }
        const idx = m.index ?? 0;
        const context = text.slice(0, idx).trim();
        const main = text.slice(idx).trim();
        const backTitle = main
          .replace(/(Definește|Defineste)/i, "Definiție")
          .trim();
        return {
          context,
          main: main || text || "În curând",
          backTitle: backTitle || "Răspuns",
        };
      }

      function ensureDeckState(deck) {
        const cards = getDeckCards(deck);
        const total = cards.length;
        if (!deck || !cards.length) return { idx: 0, statuses: [] };
        const st = deckState[deck.id] || { idx: 0, statuses: [] };
        if (!Array.isArray(st.statuses) || st.statuses.length !== total) {
          st.statuses = Array(total).fill("red");
        }
        if (st.idx >= total) st.idx = 0;
        deckState[deck.id] = st;
        return st;
      }

      function getSubjectDeckStats(subject) {
        if (!subject) return { count: 0, sum: 0 };
        let decks = [];
        if (subject.id === "fph" && window.FPH_FLASHCARDS) {
          decks = Object.values(window.FPH_FLASHCARDS).flat();
        } else if (subject.id === "fped" && window.FPED_FLASHCARDS) {
          decks = Object.values(window.FPED_FLASHCARDS).flat();
        }
        if (subject.id === "phed" && window.PHED_FLASHCARDS) {
          decks = Object.values(window.PHED_FLASHCARDS).flat();
        }
        let count = 0;
        let sum = 0;
        decks.forEach((deck) => {
          const cards = getDeckCards(deck);
          const st = ensureDeckState(deck);
          cards.forEach((_, idx) => {
            count += 1;
            if (st.statuses[idx] === "green") sum += 100;
          });
        });
        return { count, sum };
      }

      function getCapitolDeckStats(capitolId, subjectId = "fph") {
        const decks = getDecksForCapitol(capitolId, subjectId);
        let count = 0;
        let sum = 0;
        decks.forEach((deck) => {
          const cards = getDeckCards(deck);
          const st = ensureDeckState(deck);
          cards.forEach((_, idx) => {
            count += 1;
            if (st.statuses[idx] === "green") sum += 100;
          });
        });
        return { count, sum };
      }

      function isCapitolDeckComplete(capitolId, subjectId = "fph") {
        const decks = getDecksForCapitol(capitolId, subjectId);
        if (!decks.length) return false;
        return decks.every((deck) => {
          const cards = getDeckCards(deck);
          const st = ensureDeckState(deck);
          if (!cards.length) return false;
          return (
            st.statuses.length === cards.length &&
            st.statuses.every((status) => status === "green")
          );
        });
      }

      function updateCapitolPill(capitolId, subjectId = "fph") {
        const caps =
          subjectId === "phed"
            ? window.PHED_CONTENT?.capitole || []
            : window.FPH_CONTENT?.capitole || [];
        const cap = caps.find((c) => c.id === capitolId);
        if (!cap) return;
        const allTopicIds = cap.subcapitole.flatMap((s) => s.quizuri || []);
        const deckStats = getCapitolDeckStats(capitolId, subjectId);
        const quizCount = allTopicIds.length;
        const quizSum = allTopicIds.reduce(
          (sum, id) => sum + getTopicProgress(id),
          0
        );
        const quizAvg = quizCount ? quizSum / quizCount : null;
        const deckAvg = deckStats.count
          ? deckStats.sum / deckStats.count
          : null;
        let capProgress = 0;
        if (quizAvg != null && deckAvg != null) {
          capProgress = Math.round(0.5 * quizAvg + 0.5 * deckAvg);
        } else if (quizAvg != null) {
          capProgress = Math.round(quizAvg);
        } else if (deckAvg != null) {
          capProgress = Math.round(deckAvg);
        }
        const pill = capitoleContainer.querySelector(
          `[data-capitol='${capitolId}'] .pill-percent`
        );
        if (pill) {
          pill.classList.remove("red", "orange", "yellow", "green");
          pill.classList.add(pillColorClass(capProgress));
          const valEl = pill.querySelector(".pill-val");
          if (valEl) valEl.textContent = `${capProgress}%`;
          const ico = pill.querySelector(".pill-ico");
          if (ico) ico.textContent = pillIcon(capProgress);
        }
      }
      let currentTopic = null;
      let currentSubject = null;
      let currentQuizListEl = null;
      let currentQuestions = [];
      let quizCompleted = false;
      let lastCompletedTopicId = null;
      let barObserver = null;
      let floatingTooltip = null;
      let tooltipHideBound = false;

      // MMM Gestionează disponibilitatea materiilor: true = accesibil, false = blocat
      const subjectAvailability = {
        fph: true,
        fped: true,
        pdezv: true,
        phed: true,
        pedcom: false,
        lr: false,
      };

      const subjectBars = {
        fph: { base: "#b32d2d", glow: "rgba(239, 107, 107, 0.8)" },
        fped: { base: "#BE6911", glow: "rgba(226, 141, 26, 0.8)" },
        pdezv: { base: "#797428", glow: "rgba(190, 200, 130, 0.8)" },
        phed: { base: "#b02672", glow: "rgba(223, 95, 168, 0.8)" },
        pedcom: { base: "#643FAA", glow: "rgba(123, 107, 240, 0.8)" },
        lr: { base: "#165CBA", glow: "rgba(77, 141, 240, 0.8)" },
      };
      const subjectCompletionState = {};

      if (startBtn) {
        startBtn.addEventListener("click", () => {
          intro.classList.add("hidden");
          map.classList.add("visible");
        });
      } else {
        map.classList.add("visible");
      }

      cards.forEach((card) => {
        card.addEventListener("click", () => {
          const subjectId = card.dataset.id;
          card.scrollIntoView({ behavior: "smooth", block: "center" });
          openDetail(subjectId);
        });
      });

      applySubjectLocks();

      closeDetail.addEventListener("click", () => closeModal(true));
      detailOverlay.addEventListener("click", (e) => {
        if (e.target === detailOverlay) closeModal(true);
      });
      quizPanelSubmit.addEventListener("click", submitQuizAnswer);
      quizPanelRestart.addEventListener("click", restartQuiz);
      quizPanelBack.addEventListener("click", goBackToSubcap);
      backToList.addEventListener("click", goBackToSubcap);

      renderCardProgress();
      initSubjectCompletionState();
      wireTooltips(document);

      function loadProgress() {
        try {
          return JSON.parse(localStorage.getItem("subjectProgressV1")) || {};
        } catch (e) {
          return {};
        }
      }

      function saveProgress() {
        localStorage.setItem(
          "subjectProgressV1",
          JSON.stringify(progressStore)
        );
      }

      function applySubjectLocks() {
        document.querySelectorAll(".card[data-id]").forEach((card) => {
          const id = card.dataset.id;
          const isOpen = subjectAvailability[id] !== false;
          if (isOpen) {
            card.classList.remove("locked");
            const overlay = card.querySelector(".lock-overlay");
            if (overlay) overlay.remove();
          } else {
            card.classList.add("locked");
            if (!card.querySelector(".lock-overlay")) {
              const layer = document.createElement("div");
              layer.className = "lock-overlay";
              layer.innerHTML = `<span class="lock-icon"><svg viewBox="0 0 24 24" fill="none" stroke="#e2e8f0" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="5" y="10" width="14" height="10" rx="2" ry="2"></rect><path d="M8 10V7a4 4 0 0 1 8 0v3"></path></svg></span>`;
              card.appendChild(layer);
            }
          }
        });
      }

      function captureFphOpenState() {
        const state = { capitolId: null, subcaps: [], decks: [] };
        const openCap = capitoleContainer.querySelector(
          ".subcap-list.expanded"
        );
        if (openCap?.id) state.capitolId = openCap.id.replace("-subs", "");
        state.subcaps = Array.from(
          capitoleContainer.querySelectorAll(".subcap-quiz-list.expanded")
        )
          .map((el) => el.dataset.quizList)
          .filter(Boolean);
        state.decks = Array.from(
          capitoleContainer.querySelectorAll(".deck-collapsible.expanded")
        )
          .map((el) => el.dataset.deckList)
          .filter(Boolean);
        return state;
      }

      function saveFphOpenState() {
        if (!currentSubject || currentSubject.id !== "fph") return;
        const state = captureFphOpenState();
        try {
          localStorage.setItem(OPEN_STATE_KEY, JSON.stringify(state));
        } catch (e) {
          /* ignore quota errors */
        }
      }

      function loadFphOpenState() {
        try {
          return JSON.parse(localStorage.getItem(OPEN_STATE_KEY)) || null;
        } catch (e) {
          return null;
        }
      }

      function restoreFphOpenState(subject) {
        if (!subject || subject.id !== "fph") return;
        const state = loadFphOpenState();
        if (!state || !state.capitolId) return;
        const capList = document.getElementById(`${state.capitolId}-subs`);
        if (capList) {
          capList.classList.add("expanded");
          const btn = capitoleContainer.querySelector(
            `[data-toggle='${state.capitolId}']`
          );
          if (btn) setChevron(btn, true);
        }
        state.subcaps.forEach((id) => {
          const el = capitoleContainer.querySelector(
            `[data-quiz-list='${id}']`
          );
          if (el) {
            el.classList.add("expanded");
            const btn = el.previousElementSibling;
            if (btn?.classList.contains("toggle-btn")) setChevron(btn, true);
            if (el.dataset.quizIds) {
              const ids = el.dataset.quizIds.split(",").filter(Boolean);
              el.innerHTML = renderInlineQuizList(subject, ids);
              wireInlineQuizButtons(el, subject);
            }
          }
        });
        state.decks.forEach((id) => {
          const deckEl = capitoleContainer.querySelector(
            `[data-deck-list='${id}']`
          );
          if (deckEl) {
            deckEl.classList.add("expanded");
            const btn = capitoleContainer.querySelector(
              `[data-deck-toggle='${id}']`
            );
            if (btn) setChevron(btn, true);
            wireDeckInteractions(deckEl);
          }
        });
      }

      function resetAllProgress() {
        progressStore = {};
        deckState = {};
        saveProgress();
        saveDeckState();
        subjects.forEach((subject) => {
          ensureFpedData(subject);
          subjectCompletionState[subject.id] = false;
        });
        renderCardProgress();
        lastCompletedTopicId = null;
        if (currentSubject && detailOverlay.classList.contains("show")) {
          if (currentSubject.id === "fph") {
            renderCapitole(currentSubject);
          } else {
            renderTopics(currentSubject);
          }
          applySubjectBar(currentSubject);
        }
      }

      function resetModalContent() {
        topicsContainer.innerHTML = "";
        capitoleContainer.innerHTML = "";
        cards.forEach((c) => c.classList.remove("zoomed"));
        topicsContainer.classList.add("hidden");
        capitoleContainer.classList.remove("hidden");
        quizPanel.classList.add("hidden");
        quizPanelContent.innerHTML = "";
        quizPanelFeedback.textContent = "";
        quizPanelSubmit.classList.remove("hidden");
        quizPanelRestart.classList.add("hidden");
        quizPanelBack.classList.remove("hidden");
        currentQuestions = [];
        currentTopic = null;
        currentQuizListEl = null;
        quizPanel.classList.add("hidden");
        quizPanel.classList.remove("show", "exit", "complete");
        pdfLink.classList.remove("hidden");
        backToList.classList.add("hidden");
        document.body.style.overflow = "";
      }

      function closeModal(animated = true) {
        if (!detailOverlay.classList.contains("show")) return;
        const modalEl = detailOverlay.querySelector(".modal");
        const finish = () => {
          saveFphOpenState();
          detailOverlay.classList.remove("show");
          if (modalEl) modalEl.classList.remove("closing");
          resetModalContent();
        };
        if (animated && modalEl) {
          modalEl.classList.add("closing");
          setTimeout(finish, 320);
        } else {
          finish();
        }
      }

      function getTopicProgress(topicId) {
        return progressStore[topicId] ?? 0;
      }

      function setTopicProgress(topicId, value) {
        const prevAvg = currentSubject ? subjectAverage(currentSubject) : 0;
        const currentVal = progressStore[topicId] ?? 0;
        progressStore[topicId] = Math.max(currentVal, value);
        saveProgress();
        renderCardProgress();
        if (currentSubject && detailOverlay.classList.contains("show")) {
          applySubjectBar(currentSubject);
          if (currentSubject.capitole && currentSubject.capitole.length) {
            rerenderSubjectCapitolePreserveState(currentSubject);
            syncDeckHeights(capitoleContainer);
          } else if (currentQuizListEl && currentQuizListEl.dataset.quizIds) {
            const ids = currentQuizListEl.dataset.quizIds
              .split(",")
              .filter(Boolean);
            currentQuizListEl.innerHTML = renderInlineQuizList(
              currentSubject,
              ids
            );
            wireInlineQuizButtons(currentQuizListEl, currentSubject);
          }
        }
        if (currentSubject) {
          maybeCelebrateSubject(currentSubject, prevAvg);
        }
      }

      function subjectAverage(subject) {
        ensureFphData(subject);
        ensureFpedData(subject);
        ensurePhedData(subject);
        const topicCount = subject.topics?.length || 0;
        const topicSum =
          subject.topics?.reduce((sum, t) => sum + getTopicProgress(t.id), 0) ||
          0;
        const topicAvg = topicCount ? topicSum / topicCount : null;

        const deckStats = getSubjectDeckStats(subject);
        const deckAvg = deckStats.count
          ? deckStats.sum / deckStats.count
          : null;

        if (topicAvg != null && deckAvg != null) {
          return Math.round(0.5 * topicAvg + 0.5 * deckAvg);
        }
        if (topicAvg != null) return Math.round(topicAvg);
        if (deckAvg != null) return Math.round(deckAvg);
        return 0;
      }

      function getSubjectDecks(subject) {
        if (!subject) return [];
        if (subject.id === "fph" && window.FPH_FLASHCARDS) {
          return Object.values(window.FPH_FLASHCARDS).flat();
        }
        if (subject.id === "phed" && window.PHED_FLASHCARDS) {
          return Object.values(window.PHED_FLASHCARDS).flat();
        }
        return [];
      }

      function initSubjectCompletionState() {
        subjects.forEach((subject) => {
          subjectCompletionState[subject.id] = subjectAverage(subject) === 100;
        });
      }

      function applyCardCompletion(card, percent) {
        if (!card) return;
        const completed = percent >= 100;
        card.classList.toggle("completed", completed);
        const bar = card.querySelector(".progress-bar");
        if (bar) bar.classList.toggle("trophy", completed);
      }

      function launchScreenConfetti() {
        const existing = document.querySelector(".screen-confetti");
        if (existing) existing.remove();
        const colors = [
          "#f6d365",
          "#f1b24a",
          "#6be8f7",
          "#ffb703",
          "#22c55e",
          "#f97373",
        ];
        const container = document.createElement("div");
        container.className = "screen-confetti";
        for (let i = 0; i < 70; i++) {
          const piece = document.createElement("div");
          piece.className = "confetti-piece";
          piece.style.setProperty(
            "--confetti-color",
            colors[i % colors.length]
          );
          piece.style.setProperty("--confetti-left", `${Math.random() * 100}%`);
          piece.style.setProperty(
            "--confetti-dur",
            `${1.6 + Math.random() * 1.2}s`
          );
          piece.style.setProperty(
            "--confetti-rot",
            `${Math.random() * 180}deg`
          );
          container.appendChild(piece);
        }
        document.body.appendChild(container);
        setTimeout(() => container.remove(), 2200);
      }

      function showCongratsPopup(subject) {
        const existing = document.querySelector(".congrats-backdrop");
        if (existing) existing.remove();
        const backdrop = document.createElement("div");
        backdrop.className = "congrats-backdrop";
        const popup = document.createElement("div");
        popup.className = "congrats-popup";
        popup.innerHTML = `
          <div class="congrats-trophy" aria-hidden="true"></div>
          <div class="congrats-title">
            <span>FELICITĂRI!</span>
            <span>Materie 100% completată</span>
          </div>
        `;
        popup.classList.add("animate");
        backdrop.appendChild(popup);
        document.body.appendChild(backdrop);
        const close = () => backdrop.remove();
        backdrop.addEventListener("click", (e) => {
          if (e.target === backdrop) close();
        });
        setTimeout(close, 3600);
      }

      function maybeCelebrateSubject(subject, prevAvg) {
        if (!subject) return;
        const avg = subjectAverage(subject);
        if (
          avg === 100 &&
          prevAvg < 100 &&
          !subjectCompletionState[subject.id]
        ) {
          subjectCompletionState[subject.id] = true;
          launchScreenConfetti();
          showCongratsPopup(subject);
        } else if (avg < 100) {
          subjectCompletionState[subject.id] = false;
        }
      }

      function completeSubject(subject) {
        if (!subject) return;
        ensureFphData(subject);
        ensurePhedData(subject);
        (subject.topics || []).forEach((t) => {
          progressStore[t.id] = 100;
        });
        const decks = getSubjectDecks(subject);
        decks.forEach((deck) => {
          const cards = getDeckCards(deck);
          deckState[deck.id] = {
            idx: 0,
            statuses: Array(cards.length).fill("green"),
          };
        });
        saveProgress();
        saveDeckState();
        renderCardProgress();
        if (detailOverlay.classList.contains("show")) {
          if (subject.capitole && subject.capitole.length) {
            renderCapitole(subject);
            syncDeckHeights(capitoleContainer);
          } else {
            renderTopics(subject);
          }
          applySubjectBar(subject);
        }
        maybeCelebrateSubject(subject, 0);
      }

      function resetSubject(subject) {
        if (!subject) return;
        ensureFphData(subject);
        ensurePhedData(subject);
        // curăță orice chei rătăcite legate de materie (ex: id-uri vechi)
        Object.keys(progressStore || {}).forEach((key) => {
          if (key.startsWith(`${subject.id}-`)) delete progressStore[key];
        });
        (subject.topics || []).forEach((t) => {
          progressStore[t.id] = 0;
        });
        const decks = getSubjectDecks(subject);
        decks.forEach((deck) => {
          const cards = getDeckCards(deck);
          deckState[deck.id] = {
            idx: 0,
            statuses: Array(cards.length).fill("red"),
          };
        });
        Object.keys(deckState || {}).forEach((key) => {
          if (key.startsWith(`${subject.id}-`)) delete deckState[key];
        });
        saveProgress();
        saveDeckState();
        subjectCompletionState[subject.id] = false;
        renderCardProgress();
        if (detailOverlay.classList.contains("show")) {
          if (subject.capitole && subject.capitole.length) {
            renderCapitole(subject);
            syncDeckHeights(capitoleContainer);
          } else {
            renderTopics(subject);
          }
          applySubjectBar(subject);
        }
      }

      function renderCardProgress() {
        cards.forEach((card) => {
          const subject = subjects.find((s) => s.id === card.dataset.id);
          ensureFphData(subject);
          ensureFpedData(subject);
          const percent = subject ? subjectAverage(subject) : 0;
          const bar = card.querySelector(".progress-bar");
          const label = card.querySelector(".progress-label");
          if (bar) {
            bar.style.cssText = `${barStyleFor(
              subject?.id
            )} width:${percent}%;`;
            const wrap = bar.parentElement;
            if (wrap) {
              let val = wrap.querySelector(".progress-value");
              if (!val) {
                val = document.createElement("div");
                val.className = "progress-value";
                wrap.appendChild(val);
              }
              val.textContent = `${percent}%`;
            }
          }
          if (label) label.textContent = `Parcurs ${percent}%`;
          applyCardCompletion(card, percent);
        });
      }

      function openDetail(subjectId) {
        const subject = subjects.find((s) => s.id === subjectId);
        currentSubject = subject;
        if (!subject) return;
        ensurePhedData(subject);
        document.body.style.overflow = "hidden";
        ensureFphData(subject);
        detailTitle.textContent = `${subject.symbol} ${subject.name}`;
        detailDesc.textContent =
          "Selectează capitolele și subcapitolele pentru a deschide quizurile aferente. Progresul se salvează local.";
        detailDesc.classList.add("hidden");
        applySubjectBar(subject);
        backToList.classList.add("hidden");
        pdfLink.classList.remove("hidden");
        if (subjectProgressWrap) subjectProgressWrap.classList.add("hidden");
        pdfLink.href = subject.pdf;
        pdfLink.textContent = subject.pdf ? "Deschide PDF" : "PDF neatașat";
        if (subject.capitole && subject.capitole.length) {
          topicsContainer.classList.add("hidden");
          capitoleContainer.classList.remove("hidden");
          renderCapitole(subject);
          restoreFphOpenState(subject);
        } else {
          topicsContainer.classList.remove("hidden");
          capitoleContainer.classList.add("hidden");
          capitoleContainer.innerHTML = "";
          renderTopics(subject);
        }
        detailOverlay.classList.add("show");
        const modalEl = detailOverlay.querySelector(".modal");
        requestAnimationFrame(() => {
          (modalEl || detailOverlay).scrollTo({
            top: 0,
            behavior: "smooth",
          });
          window.scrollTo({ top: 0, behavior: "smooth" });
        });
      }

      function renderCapitole(subject) {
        ensureFphData(subject);
        ensurePhedData(subject);
        if (!subject.capitole || !subject.capitole.length) {
          capitoleContainer.innerHTML = `<div class="empty">Nu există capitole definite încă.</div>`;
          return;
        }

        capitoleContainer.innerHTML = subject.capitole
          .map((capitol, idx) => {
            const allTopicIds = capitol.subcapitole.flatMap(
              (s) => s.quizuri || []
            );
            const deckStats = getCapitolDeckStats(capitol.id, subject.id);
            const quizCount = allTopicIds.length;
            const quizSum = allTopicIds.reduce(
              (sum, id) => sum + getTopicProgress(id),
              0
            );
            const quizAvg = quizCount ? quizSum / quizCount : null;
            const deckAvg = deckStats.count
              ? deckStats.sum / deckStats.count
              : null;
            const deckComplete = isCapitolDeckComplete(capitol.id, subject.id);
            let capProgress = 0;
            if (quizAvg != null && deckAvg != null) {
              capProgress = Math.round(0.5 * quizAvg + 0.5 * deckAvg);
            } else if (quizAvg != null) {
              capProgress = Math.round(quizAvg);
            } else if (deckAvg != null) {
              capProgress = Math.round(deckAvg);
            }

            return `
              <div class="capitol" data-capitol="${capitol.id}">
                  <div class="capitol-header">
                    <div style="flex:1; display:flex; align-items:center; gap:8px; min-width:0; width:100%;">
                      <div class="pill pill-course" style="background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.12); width:100%; justify-content:space-between;">
                        <span style="font-size:1.1rem;">📑</span>
                        <span style="font-weight:800; flex:1; min-width:0;">${
                          capitol.titlu
                        }</span>
                        <span class="pill-percent ${pillColorClass(
                          capProgress
                        )}"><span class="pill-val">${capProgress}%</span> <span class="pill-ico">${pillIcon(
              capProgress
            )}</span></span>
                      </div>
                    </div>
                    <div class="capitol-actions" style="justify-content:flex-end;">
                    <button class="quiz-btn toggle-btn" data-toggle="${
                      capitol.id
                    }">
                      <span>Subcapitole</span>
                      <span class="chevron">🔽</span>
                    </button>
                  </div>
                  </div>
                <div class="subcap-list collapsible" id="${capitol.id}-subs">
                  ${capitol.subcapitole
                    .map((s) => {
                      const quizIds = s.quizuri || [];
                      const completedAll = quizIds.length
                        ? quizIds.every((id) => getTopicProgress(id) === 100)
                        : false;
                      return `
                      <div class="subcap">
                        <div class="subcap-header">
                          <div class="subcap-title">
                            <span class="subcap-status ${
                              completedAll ? "done" : ""
                            }">${completedAll ? "✓" : ""}</span>
                            <span>${s.titlu}</span>
                          </div>
                          <button class="quiz-btn toggle-btn secondary" data-quiz-ids="${quizIds.join(
                            ","
                          )}">
                            <span>QUIZURI</span>
                            <span class="chevron">🔽</span>
                          </button>
                        </div>
                        <div class="subcap-quiz-list collapsible" data-quiz-list="${
                          s.id
                        }" data-quiz-ids="${quizIds.join(",")}"></div>
                      </div>
                    `;
                    })
                    .join("")}
                  <div class="subcap deck-subcap" style="background:linear-gradient(135deg,rgba(120,90,200,0.14),rgba(48,40,72,0.34));border:1px solid rgba(255,255,255,0.18);border-radius:14px;padding:12px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.16), 0 12px 28px rgba(0,0,0,0.2);">
                    <div class="subcap-header" style="align-items:center;">
                      <div class="subcap-title">
                        <span class="subcap-status ${
                          deckComplete ? "done" : ""
                        }">${deckComplete ? "✓" : ""}</span>
                        <span>FLASHCARDS</span>
                      </div>
                      <button class="quiz-btn toggle-btn secondary deck-toggle-btn" data-deck-toggle="${
                        capitol.id
                      }" style="padding:10px 14px;border-radius:12px;background:linear-gradient(135deg,rgba(105,125,165,0.32),rgba(80,98,140,0.32));border:1px solid rgba(255,255,255,0.24);backdrop-filter:blur(6px);color:#eef2ff;box-shadow:0 8px 18px rgba(0,0,0,0.18);">
                        <span style="opacity:0.9;font-weight:800;">CARDURI</span>
                        <span class="chevron">🔽</span>
                      </button>
                    </div>
                    <div class="deck-collapsible collapsible" data-deck-list="${
                      capitol.id
                    }">
                      ${renderDeckRow(subject.id, capitol.id)}
                    </div>
                  </div>
                </div>
              </div>
            `;
          })
          .join("");

        capitoleContainer.querySelectorAll("[data-toggle]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const targetId = btn.dataset.toggle;
            const list = document.getElementById(`${targetId}-subs`);
            if (list) {
              const willExpand = !list.classList.contains("expanded");
              // close all other capitole
              capitoleContainer
                .querySelectorAll(".subcap-list.expanded")
                .forEach((el) => {
                  if (el !== list) {
                    el.classList.remove("expanded");
                    el.querySelectorAll(".subcap-quiz-list").forEach((s) =>
                      s.classList.remove("expanded")
                    );
                    el.querySelectorAll(".deck-collapsible").forEach((d) =>
                      d.classList.remove("expanded")
                    );
                  }
                });
              capitoleContainer
                .querySelectorAll(".capitol .chevron")
                .forEach((c) => (c.style.transform = "rotate(0deg)"));
              if (willExpand) {
                list.classList.add("expanded");
                setChevron(btn, true);
                const capEl = btn.closest(".capitol") || list;
                capEl.scrollIntoView({ behavior: "smooth", block: "start" });
              } else {
                list.classList.remove("expanded");
                setChevron(btn, false);
                // closing the capitol collapses all its subcapitole/quiz lists
                list
                  .querySelectorAll(".subcap-quiz-list")
                  .forEach((el) => el.classList.remove("expanded"));
                list
                  .querySelectorAll(".deck-collapsible")
                  .forEach((el) => el.classList.remove("expanded"));
                list
                  .querySelectorAll(".subcap .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
                list
                  .querySelectorAll(".deck-toggle-btn .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
              }
              topicsContainer.classList.add("hidden");
              quizPanel.classList.add("hidden");
            }
          });
        });

        capitoleContainer.querySelectorAll("[data-quiz-ids]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const ids = btn.dataset.quizIds.split(",").filter(Boolean);
            const quizList =
              btn.closest(".subcap")?.querySelector(".subcap-quiz-list") ||
              btn.nextElementSibling;
            if (quizList) {
              const willExpand = !quizList.classList.contains("expanded");
              // close siblings within the same capitol
              const parentCapitol = quizList.closest(".capitol");
              if (parentCapitol) {
                parentCapitol
                  .querySelectorAll(".subcap-quiz-list.expanded")
                  .forEach((el) => {
                    if (el !== quizList) el.classList.remove("expanded");
                  });
                parentCapitol
                  .querySelectorAll(".subcap .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
                parentCapitol
                  .querySelectorAll(".deck-collapsible.expanded")
                  .forEach((el) => el.classList.remove("expanded"));
                parentCapitol
                  .querySelectorAll(".deck-toggle-btn .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
              }
              quizList.innerHTML = renderInlineQuizList(subject, ids);
              quizList.dataset.quizIds = ids.join(",");
              if (willExpand) {
                quizList.classList.add("expanded");
                setChevron(btn, true);
                requestAnimationFrame(() =>
                  scrollListIntoViewIfHidden(quizList)
                );
              } else {
                quizList.classList.remove("expanded");
                setChevron(btn, false);
              }
            }
            topicsContainer.classList.add("hidden");
            wireInlineQuizButtons(quizList, subject);
          });
        });

        capitoleContainer
          .querySelectorAll("[data-deck-toggle]")
          .forEach((btn) => {
            btn.addEventListener("click", () => {
              const deckTarget = btn.dataset.deckToggle;
              const deckList = capitoleContainer.querySelector(
                `[data-deck-list='${deckTarget}']`
              );
              if (!deckList) return;
              const willExpand = !deckList.classList.contains("expanded");
              const parentCapitol = btn.closest(".capitol");
              if (parentCapitol) {
                parentCapitol
                  .querySelectorAll(".subcap-quiz-list.expanded")
                  .forEach((el) => el.classList.remove("expanded"));
                parentCapitol
                  .querySelectorAll(".deck-collapsible.expanded")
                  .forEach((el) => {
                    if (el !== deckList) el.classList.remove("expanded");
                  });
                parentCapitol
                  .querySelectorAll(".subcap .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
                parentCapitol
                  .querySelectorAll(".deck-toggle-btn .chevron")
                  .forEach((c) => (c.style.transform = "rotate(0deg)"));
              }
              if (willExpand) {
                deckList.classList.add("expanded");
                setChevron(btn, true);
                scrollIntoModalView(deckList, 64);
              } else {
                deckList.classList.remove("expanded");
                setChevron(btn, false);
              }
              topicsContainer.classList.add("hidden");
              quizPanel.classList.add("hidden");
              wireDeckInteractions(deckList);
              wireTooltips(deckList);
              syncDeckHeights(deckList);
            });
          });

        wireDeckInteractions(capitoleContainer);
        wireTooltips(capitoleContainer);
        syncDeckHeights(capitoleContainer);
      }

      function renderTopics(subject, topicIds) {
        ensureFphData(subject);
        const list = topicIds
          ? subject.topics.filter((t) => topicIds.includes(t.id))
          : subject.topics;

        if (!list.length) {
          topicsContainer.innerHTML = `<div class="empty">Nu există topicuri definite încă.</div>`;
          return;
        }

        topicsContainer.innerHTML = list
          .map((topic) => {
            const percent = getTopicProgress(topic.id);
            const barStyle = barStyleFor(subject.id);
            return `
              <div class="topic">
            <div>
              <strong>${topic.title}</strong>
              <div class="meta">Răspuns corect: ${percent}%</div>
              <div class="progress">
                <div class="progress-bar" data-target="${percent}" style="width:${percent}%; ${barStyle}"></div>
                <div class="progress-value">${percent}%</div>
              </div>
            </div>
            <button class="quiz-btn" data-topic="${topic.id}">START QUIZ</button>
          </div>
        `;
          })
          .join("");

        updateBarWidths(topicsContainer, false);
        topicsContainer.querySelectorAll(".quiz-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const topicId = btn.dataset.topic;
            const topic = subject.topics.find((t) => t.id === topicId);
            openQuiz(subject, topic);
          });
        });
      }

      function renderInlineQuizList(subject, ids) {
        const list = ids.length
          ? subject.topics.filter((t) => ids.includes(t.id))
          : [];
        if (!list.length) {
          return `<div class="empty">Nu există quizuri pentru acest subcapitol.</div>`;
        }
        return list
          .map((topic) => {
            const percent = getTopicProgress(topic.id);
            const barStyle = barStyleFor(subject.id);
            return `
            <div class="topic" data-topic-container="${topic.id}" style="margin-top:12px;">
              <div>
                <strong>${topic.title}</strong>
                <div class="meta">Răspuns corect: ${percent}%</div>
                <div class="progress">
                  <div class="progress-bar" data-target="${percent}" style="width:${percent}%; ${barStyle}"></div>
                  <div class="progress-value">${percent}%</div>
                </div>
              </div>
              <button class="quiz-btn" style="padding: 10px;" data-topic="${topic.id}">START QUIZ</button>
            </div>
          `;
          })
          .join("");
      }

      function getDecksForCapitol(capitolId, subjectId = "fph") {
        if (subjectId === "fped") {
          return (
            (window.FPED_FLASHCARDS && window.FPED_FLASHCARDS[capitolId]) || []
          );
        }
        if (subjectId === "phed") {
          return (
            (window.PHED_FLASHCARDS && window.PHED_FLASHCARDS[capitolId]) || []
          );
        }
        return (
          (window.FPH_FLASHCARDS && window.FPH_FLASHCARDS[capitolId]) || []
        );
      }

      function renderDeckRow(subjectId, capitolId) {
        const decks = getDecksForCapitol(capitolId, subjectId);
        if (!decks.length) return "";
        const rowStyle =
          "display:flex;flex-wrap:wrap;gap:16px;margin-top:18px;align-items:stretch;backdrop-filter:blur(4px);";
        return `<div class="deck-row" data-deck-subject="${subjectId}" data-deck-capitol="${capitolId}" style="${rowStyle}">
          ${decks
            .map((deck) => {
              const cards = getDeckCards(deck);
              const state = ensureDeckState(deck);
              const available = cards
                .map((_, i) => i)
                .filter((i) => state.statuses[i] !== "green");
              const allGreen = cards.length > 0 && available.length === 0;
              let currentIdx = state.idx || 0;
              if (!allGreen && !available.includes(currentIdx)) {
                currentIdx = available[0] || 0;
                state.idx = currentIdx;
                deckState[deck.id] = state;
              }
              const card = cards[currentIdx] || {};
              const promptParts = parseFrontParts(card);
              const backContent = splitBackContent(card);
              const redCount = state.statuses.filter((s) => s === "red").length;
              const yellowCount = state.statuses.filter(
                (s) => s === "yellow"
              ).length;
              const greenCount = state.statuses.filter(
                (s) => s === "green"
              ).length;
              const displayTitle =
                deck.title && deck.title.includes("Deck 1")
                  ? "Carduri CURS 1"
                  : deck.title || "Deck";
              const boxStyle =
                "flex:1 1 320px;position:relative;overflow:hidden;border-radius:16px;padding:28px;background:linear-gradient(145deg,rgba(255,255,255,0.06),rgba(47,29,64,0.55));border:1px solid rgba(255,255,255,0.12);box-shadow:0 18px 40px rgba(0,0,0,0.32),inset 0 1px 0 rgba(255,255,255,0.12);display:grid;gap:20px;";
              const headerStyle =
                "display:flex;align-items:center;justify-content:space-between;gap:10px;";
              const titleStyle =
                "font-weight:800;color:#f8fafc;letter-spacing:0.01em;font-size:1.02rem;";
              const pillStyle =
                "display:inline-flex;align-items:center;gap:6px;padding:6px 12px;border-radius:999px;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.16);font-weight:800;color:#e2e8f0;";
              const cardsStyle = "display:grid;gap:26px;padding:18px 0;";
              const cardStyle =
                "background:linear-gradient(150deg,rgba(255,255,255,0.08),rgba(55,32,70,0.42));border:1px solid rgba(255,255,255,0.14);box-shadow:0 18px 46px rgba(0,0,0,0.35),inset 0 1px 0 rgba(255,255,255,0.18);padding:34px;border-radius:16px;position:relative;min-height:520px;max-width:760px;margin:0 auto;display:grid;gap:28px;";
              const chipStyle =
                "display:inline-flex;align-items:center;gap:6px;background:rgba(34,211,238,0.18);border:1px solid rgba(34,211,238,0.45);color:#a5f3fc;border-radius:999px;padding:9px 13px;font-weight:800;letter-spacing:0.01em;width:fit-content;box-shadow:0 10px 26px rgba(34,211,238,0.28);";
              const frontContextStyle =
                "font-size:clamp(0.95rem, 1.6vw, 1.1rem);color:#d6dee9;line-height:1.6;text-align:center;max-width:760px;margin:0 auto;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);border-radius:12px;padding:16px 18px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.14), 0 6px 18px rgba(0,0,0,0.18);";
              const frontStyle =
                "font-weight:800;font-size:clamp(1.4rem, 3vw, 2rem);color:#f8fafc;line-height:1.6;display:flex;align-items:center;justify-content:center;text-align:center;min-height:180px;padding:18px;max-width:680px;margin:0 auto;";
              const backStyle =
                "color:#e6edf3;font-size:0.98rem;line-height:1.6;display:grid;gap:24px;max-width:800px; margin:0 auto;";
              const shellStyle =
                "position:relative;perspective:1200px;transform-style:preserve-3d;transition:transform 0.6s cubic-bezier(0.22,1,0.36,1);width:100%;min-height:500px;";
              const faceBase =
                "position:absolute;inset:0;padding:20px;border-radius:14px;backface-visibility:hidden;background:linear-gradient(150deg,rgba(255,255,255,0.08),rgba(52,30,66,0.34));display:grid;gap:24px;align-content:center;justify-items:center;box-sizing:border-box;";
              const backFace = "transform:rotateY(180deg);";
              const btnFlipStyle =
                "margin-top:12px;display:inline-flex;align-items:center;justify-content:center;gap:10px;padding:14px 18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);background:linear-gradient(135deg,#22d3ee,#4f46e5);color:#f8fafc;font-weight:800;letter-spacing:0.01em;cursor:pointer;box-shadow:0 14px 30px rgba(79,70,229,0.35);width:100%;";
              const actionsRow =
                "display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:16px;width:100%;max-width:100%;margin-left:auto;margin-right:auto;";
              const actionBase =
                "border:none;border-radius:14px;padding:14px 12px;font-weight:800;color:#ffffff;cursor:pointer;box-shadow:0 14px 30px rgba(0,0,0,0.3);letter-spacing:0.01em;transition:transform 0.15s ease, box-shadow 0.15s ease;animation:shinePulse 2.6s ease-in-out infinite;";
              const btnRed = `${actionBase} background:linear-gradient(135deg,#f97373,#ef4444);`;
              const btnYellow = `${actionBase} background:linear-gradient(135deg,#facc15,#f59e0b);`;
              const btnGreen = `${actionBase} background:linear-gradient(135deg,#22c55e,#16a34a);`;
              const dotRow =
                "display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:0;";
              const dotBase =
                "display:inline-flex;align-items:center;justify-content:center;width:36px;height:36px;border-radius:999px;font-weight:800;font-size:0.95rem;box-shadow:0 10px 18px rgba(0,0,0,0.22);animation:shinePulse 3s ease-in-out infinite;";
              const dotRed = `${dotBase} background:linear-gradient(135deg,#f97373,#ef4444);color:#ffffff;`;
              const dotYellow = `${dotBase} background:linear-gradient(135deg,#facc15,#f59e0b);color:#ffffff;`;
              const dotGreen = `${dotBase} background:linear-gradient(135deg,#22c55e,#16a34a);color:#ffffff;`;
              const congratsStyle =
                "padding:16px;border-radius:14px;background:linear-gradient(135deg,rgba(34,211,238,0.22),rgba(79,70,229,0.25));border:1px solid rgba(255,255,255,0.14);color:#e2e8f0;display:grid;gap:16px;place-items:center;text-align:center;";
              const resetBtnStyle =
                "display:inline-flex;align-items:center;gap:8px;padding:12px 16px;border-radius:12px;border:1px solid rgba(255,255,255,0.16);background:linear-gradient(135deg,#22d3ee,#4f46e5);color:#f8fafc;font-weight:800;letter-spacing:0.01em;cursor:pointer;box-shadow:0 14px 30px rgba(79,70,229,0.35);";
              return `
                <div class="deck-box deck-primary deck-static" data-deck-id="${
                  deck.id
                }" data-deck-subject="${subjectId}" data-deck-capitol="${capitolId}" data-card-idx="${currentIdx}" style="${boxStyle}">
                  <div class="deck-header" style="${headerStyle}">
                    <div class="deck-title" style="${titleStyle}">${displayTitle}</div>
                    <span class="deck-score-pill" style="${pillStyle}">${
                cards.length
              } carduri</span>
                  </div>
                  <div class="deck-cards" style="${cardsStyle}">
                    <div class="deck-status-row" style="display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:0;">
                      <div class="deck-dots" style="${dotRow}">
                        <span style="${dotRed}">${redCount}</span>
                        <span style="${dotYellow}">${yellowCount}</span>
                        <span style="${dotGreen}">${greenCount}</span>
                      </div>
                    </div>
                    ${
                      allGreen
                        ? `
                      <div class="deck-card static feature" style="${cardStyle} min-height:auto; gap:18px; padding:28px; max-width:720px;">
                        <div style="${congratsStyle}">
                          <div style="font-weight:800;font-size:1rem;">Felicitări! Cunoști toate conceptele! 🎉</div>
                          <button type="button" class="deck-reset-btn" data-deck-reset="${deck.id}" style="${resetBtnStyle}">Ia-le de la capăt</button>
                        </div>
                      </div>`
                        : `
                      <div class="deck-card static feature">
                        <div class="flip-shell" data-flip-shell="${
                          deck.id
                        }" style="${shellStyle}">
                          <div class="flip-face front" style="${faceBase}">
                            ${
                              promptParts.context
                                ? `<div style="${frontContextStyle}">${promptParts.context}</div>`
                                : ""
                            }
                            <div class="deck-front" style="${frontStyle}">${
                            promptParts.main
                          }</div>
                            <button type="button" class="deck-flip-btn" data-flip-target="${
                              deck.id
                            }" style="${btnFlipStyle}">Arată răspunsul</button>
                          </div>
                          <div class="flip-face back" style="${faceBase} ${backFace}">
                            <div class="deck-back" style="${backStyle}">
                              <div style="font-weight:800;color:#fff;text-align:center;text-shadow:0 2px 12px rgba(0,0,0,0.45);letter-spacing:0.01em;font-size:135%;">${
                                promptParts.backTitle
                              }:</div>
                              <div style="color:#e6edf3;font-size:1.05rem;font-weight:600;">${
                                backContent.academic
                              }</div>
                              ${
                                backContent.simplified
                                  ? `<div style="background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.14);border-radius:12px;padding:16px 14px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.18);color:#eef2ff;font-weight:700;">${backContent.simplified}</div>`
                                  : ""
                              }
                            </div>
                            <div class="deck-actions" style="${actionsRow}">
                              <button type="button" class="deck-action deck-action-red" data-deck-action="again" style="${btnRed}">Nu am știut</button>
                              <button type="button" class="deck-action deck-action-yellow" data-deck-action="hard" style="${btnYellow}">Mai am scăpări</button>
                              <button type="button" class="deck-action deck-action-green" data-deck-action="good" style="${btnGreen}">Îl știu</button>
                            </div>
                          </div>
                        </div>
                       
                      </div>`
                    }
                  </div>
                </div>
              `;
            })
            .join("")}
        </div>`;
      }

      function refreshDeckRow(capitolId) {
        const row = capitoleContainer.querySelector(
          `.deck-row[data-deck-capitol='${capitolId}']`
        );
        if (!row) return;
        const subj = row.dataset.deckSubject || "fph";
        row.outerHTML = renderDeckRow(subj, capitolId);
        const newRow = capitoleContainer.querySelector(
          `.deck-row[data-deck-capitol='${capitolId}']`
        );
        const mountTarget = newRow || capitoleContainer;
        wireDeckInteractions(mountTarget);
        wireTooltips(mountTarget);
        const firstCard = mountTarget.querySelector(".deck-card");
        if (firstCard) {
          firstCard.classList.add("fade-in-card");
          requestAnimationFrame(() =>
            firstCard.classList.add("fade-in-card-active")
          );
          setTimeout(() => {
            firstCard.classList.remove("fade-in-card", "fade-in-card-active");
          }, 320);
        }
        syncDeckHeights(mountTarget);
        const subj2 =
          mountTarget.querySelector(".deck-row")?.dataset.deckSubject;
        updateDeckCompletion(capitolId, subj2 || "fph");
      }

      function syncDeckHeights(root = document) {
        root.querySelectorAll("[data-flip-shell]").forEach((shell) => {
          const front = shell.querySelector(".flip-face.front");
          const back = shell.querySelector(".flip-face.back");
          if (!front || !back) return;
          const h = Math.max(front.scrollHeight, back.scrollHeight, 420);
          shell.style.minHeight = `${h}px`;
          shell.style.height = "";
        });
      }

      function updateDeckCompletion(capitolId, subjectId = "fph") {
        const done = isCapitolDeckComplete(capitolId, subjectId);
        const subcap = capitoleContainer
          .querySelector(`.deck-subcap [data-deck-list='${capitolId}']`)
          ?.closest(".deck-subcap");
        if (subcap) {
          const status = subcap.querySelector(".subcap-status");
          if (status) {
            status.classList.toggle("done", done);
            status.textContent = done ? "✓" : "";
          }
        }
      }

      function wireDeckInteractions(root = document) {
        const syncHeights = (shell) => {
          const front = shell.querySelector(".flip-face.front");
          const back = shell.querySelector(".flip-face.back");
          if (!front || !back) return;
          requestAnimationFrame(() => {
            const h = Math.max(front.scrollHeight, back.scrollHeight, 420);
            shell.style.minHeight = `${h}px`;
            shell.style.height = "";
          });
        };

        root.querySelectorAll("[data-flip-target]").forEach((btn) => {
          if (btn.dataset.flipBound === "true") return;
          const target = btn.dataset.flipTarget;
          const shell = root.querySelector(`[data-flip-shell=\"${target}\"]`);
          if (!shell) return;
          btn.dataset.flipBound = "true";
          syncHeights(shell);
          btn.addEventListener("click", () => {
            const flipped = shell.dataset.flipped === "true";
            shell.dataset.flipped = flipped ? "false" : "true";
            shell.style.transform = flipped
              ? "rotateY(0deg)"
              : "rotateY(180deg)";
            btn.textContent = flipped ? "Arată răspunsul" : "Ascunde răspunsul";
          });
        });

        root.querySelectorAll(".deck-action").forEach((btn) => {
          if (btn.dataset.deckBound === "true") return;
          btn.dataset.deckBound = "true";
          btn.addEventListener("click", () => {
            const deckBox = btn.closest("[data-deck-id]");
            if (!deckBox) return;
            const deckId = deckBox.dataset.deckId;
            const capitolId =
              deckBox.dataset.deckCapitol ||
              deckBox.closest(".deck-row")?.dataset.deckCapitol;
            const subj = deckBox.dataset.deckSubject || "fph";
            const subject = subjects.find((s) => s.id === subj);
            const prevAvg = subject ? subjectAverage(subject) : 0;
            const decks = getDecksForCapitol(capitolId, subj);
            const deck = decks.find((d) => d.id === deckId);
            if (!deck || !deck.cards || !deck.cards.length) return;
            const st = ensureDeckState(deck);
            const currentIdx =
              parseInt(deckBox.dataset.cardIdx || "0", 10) || 0;
            const cardEl = btn.closest(".deck-card");
            if (cardEl) cardEl.classList.add("fade-out");
            const nextIdx = (() => {
              const total = getDeckCards(deck).length;
              for (let offset = 1; offset <= total; offset++) {
                const idx = (currentIdx + offset) % total;
                if (st.statuses[idx] !== "green") return idx;
              }
              return 0;
            })();
            if (btn.dataset.deckAction === "again") {
              st.statuses[currentIdx] = "red";
            } else if (btn.dataset.deckAction === "hard") {
              st.statuses[currentIdx] = "yellow";
            } else if (btn.dataset.deckAction === "good") {
              st.statuses[currentIdx] = "green";
            }
            st.idx = nextIdx;
            deckState[deckId] = st;
            saveDeckState();
            setTimeout(() => {
              refreshDeckRow(capitolId);
              renderCardProgress();
              const subj = deckBox.dataset.deckSubject || "fph";
              updateCapitolPill(capitolId, subj);
              updateDeckCompletion(capitolId, subj);
              syncDeckHeights(capitoleContainer);
              if (subject) {
                maybeCelebrateSubject(subject, prevAvg);
              }
            }, 260);
          });
        });

        root.querySelectorAll(".deck-reset-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            const deckBox = btn.closest("[data-deck-id]");
            if (!deckBox) return;
            const deckId = deckBox.dataset.deckId;
            const capitolId =
              deckBox.dataset.deckCapitol ||
              deckBox.closest(".deck-row")?.dataset.deckCapitol;
            const subj = deckBox.dataset.deckSubject || "fph";
            const subject = subjects.find((s) => s.id === subj);
            const decks = getDecksForCapitol(capitolId, subj);
            const deck = decks.find((d) => d.id === deckId);
            if (!deck || !deck.cards || !deck.cards.length) return;
            const st = ensureDeckState(deck);
            st.statuses = Array(getDeckCards(deck).length).fill("red");
            st.idx = 0;
            deckState[deckId] = st;
            saveDeckState();
            refreshDeckRow(capitolId);
            renderCardProgress();
            if (
              currentSubject &&
              currentSubject.capitole &&
              detailOverlay.classList.contains("show")
            ) {
              rerenderSubjectCapitolePreserveState(currentSubject);
            }
            if (subject) {
              maybeCelebrateSubject(subject, 100);
            }
          });
        });
      }

      function wireInlineQuizButtons(container, subject) {
        if (!container) return;
        container.querySelectorAll("[data-topic]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const topicId = btn.dataset.topic;
            const topic = subject.topics.find((t) => t.id === topicId);
            openQuiz(subject, topic, container);
          });
        });
        updateBarWidths(container, false);
      }

      function scrollListIntoViewIfHidden(listEl) {
        if (!listEl) return;
        const modal = detailOverlay.querySelector(".modal");
        if (!modal) return;
        const modalRect = modal.getBoundingClientRect();
        const listRect = listEl.getBoundingClientRect();
        const offset = 72; // 12px padding + ~100px extra to nudge higher
        const isAboveView = listRect.top < modalRect.top + 12;
        if (isAboveView) {
          const targetTop =
            modal.scrollTop + (listRect.top - modalRect.top) - offset;
          modal.scrollTo({
            top: Math.max(targetTop, 0),
            behavior: "smooth",
          });
        }
      }

      function setChevron(btn, expanded) {
        const chev = btn.querySelector(".chevron");
        if (!chev) return;
        chev.style.transform = expanded ? "rotate(180deg)" : "rotate(0deg)";
      }

      function scrollIntoModalView(target, offset = 0) {
        const modal = detailOverlay.querySelector(".modal");
        if (!modal || !target) return;
        const rect = target.getBoundingClientRect();
        const mRect = modal.getBoundingClientRect();
        const top = modal.scrollTop + (rect.top - mRect.top) - offset;
        modal.scrollTo({ top: Math.max(top, 0), behavior: "smooth" });
      }

      function barStyleFor(subjectId) {
        const style = subjectBars[subjectId] || subjectBars.fph;
        return `--bar-base:${style.base}; --bar-glow:${style.glow};`;
      }

      function pillColorClass(val) {
        if (val >= 100) return "green";
        if (val >= 60) return "yellow";
        if (val >= 10) return "orange";
        return "red";
      }

      function pillIcon(val) {
        if (val >= 100) return "✅";
        if (val >= 60) return "💡";
        if (val >= 10) return "🤓";
        return "💤";
      }

      function wireTooltips(scope = document) {
        const tips = scope.querySelectorAll(".tip");
        tips.forEach((tip) => {
          if (tip.dataset.tipBound === "true") return;
          tip.dataset.tipBound = "true";
          const box = tip.querySelector(".tooltip-box");
          if (!box) return;
          let floating = null;
          const show = () => {
            const rect = (icon || tip).getBoundingClientRect();
            if (!floatingTooltip) {
              floatingTooltip = document.createElement("div");
              floatingTooltip.className = "tooltip-floating";
              document.body.appendChild(floatingTooltip);
            }
            floating = floatingTooltip;
            floating.innerHTML = box.innerHTML;
            floating.style.display = "block";
            floating.style.opacity = "0";
            const bRect = floating.getBoundingClientRect();
            let left = rect.left + rect.width / 2 - bRect.width / 2;
            left = Math.max(
              8,
              Math.min(left, window.innerWidth - bRect.width - 8)
            );
            let top = rect.top - bRect.height - 8;
            if (top < 8) top = rect.bottom + 8;
            if (top + bRect.height > window.innerHeight - 8) {
              top = window.innerHeight - bRect.height - 8;
            }
            if (top < 8) top = 8;
            floating.style.left = `${left}px`;
            floating.style.top = `${top}px`;
            floating.style.opacity = "1";
            floating.dataset.tipId = tip.dataset.tipId || "";
          };
          const hide = () => {
            if (floatingTooltip) {
              floatingTooltip.style.display = "none";
              floatingTooltip.style.opacity = "0";
              floatingTooltip.dataset.tipId = "";
            }
          };
          const toggle = (event) => {
            if (event) {
              event.preventDefault();
              event.stopPropagation();
            }
            const activeId = floatingTooltip?.dataset.tipId || "";
            const currentId = tip.dataset.tipId || "";
            if (floatingTooltip && floatingTooltip.style.display === "block") {
              if (activeId && activeId === currentId) {
                hide();
                return;
              }
            }
            show();
          };
          if (!tip.dataset.tipId) {
            tip.dataset.tipId = `tip-${Math.random().toString(36).slice(2, 9)}`;
          }
          let icon = tip.querySelector(".tooltip-icon");
          if (!icon && !tip.classList.contains("help-tip")) {
            icon = document.createElement("span");
            icon.className = "tooltip-icon";
            icon.setAttribute("aria-hidden", "true");
            tip.appendChild(icon);
          }
          if (!icon) icon = tip;

          // underline remains regardless of word count
          icon.addEventListener("mouseenter", show);
          icon.addEventListener("mousemove", show);
          icon.addEventListener("mouseleave", hide);
          icon.addEventListener("touchstart", toggle, { passive: false });
          icon.addEventListener("click", toggle);
          if (!tooltipHideBound) {
            tooltipHideBound = true;
            document.addEventListener("click", (e) => {
              const target = e.target;
              if (
                target &&
                target.closest &&
                target.closest(".tip, .tooltip-floating")
              ) {
                return;
              }
              hide();
            });
            document.addEventListener(
              "touchstart",
              (e) => {
                const target = e.target;
                if (
                  target &&
                  target.closest &&
                  target.closest(".tip, .tooltip-floating")
                ) {
                  return;
                }
                hide();
              },
              { passive: true }
            );
            window.addEventListener("scroll", hide, { passive: true });
            window.addEventListener("resize", hide);
          }
        });
      }

      function applySubjectBar(subject) {
        if (!subject) return;
        ensurePhedData(subject);
        const avg = subjectAverage(subject);
        subjectProgressLabel.textContent = `Parcurs ${avg}%`;
        if (subjectProgressBar) {
          subjectProgressBar.style.cssText = `width:${avg}%; ${barStyleFor(
            subject.id
          )}`;
        }
      }

      function updateBarWidths(container, animate, onlyTopicId) {
        if (!container) return;
        const bars = container.querySelectorAll(".progress-bar[data-target]");
        bars.forEach((bar) => {
          if (onlyTopicId) {
            const parentTopic = bar.closest("[data-topic-container]");
            if (
              !parentTopic ||
              parentTopic.dataset.topicContainer !== onlyTopicId
            )
              return;
          }
          const target = Number(bar.dataset.target || 0);
          const progressWrap = bar.parentElement;
          if (progressWrap) {
            let valEl = progressWrap.querySelector(".progress-value");
            if (!valEl) {
              valEl = document.createElement("div");
              valEl.className = "progress-value";
              progressWrap.appendChild(valEl);
            }
            valEl.textContent = `${target}%`;
            const pillColor = progressWrap
              .closest(".pill-course")
              ?.querySelector(".pill-percent");
            if (pillColor) {
              const match = pillColor.textContent.match(/(\d+)/);
              const val = match ? Number(match[1]) : 0;
              pillColor.classList.remove("red", "orange", "yellow", "green");
              pillColor.classList.add(pillColorClass(val));
              const ico = pillColor.querySelector(".pill-ico");
              const valSpan = pillColor.querySelector(".pill-val");
              if (ico) ico.textContent = pillIcon(val);
              if (valSpan) valSpan.textContent = `${val}%`;
            }
          }
          if (animate) {
            bar.style.width = "0%";
            bar.offsetHeight; // reflow
            requestAnimationFrame(() => {
              bar.style.width = `${target}%`;
            });
          } else {
            bar.style.width = `${target}%`;
          }
        });
      }

      function ensureFphData(subject) {
        if (!subject || subject.id !== "fph") return;
        const data = window.FPH_CONTENT || {};
        if (!subject.capitole?.length) {
          subject.capitole = data.capitole || [];
        }
        if (!subject.topics?.length) {
          subject.topics = data.topics || [];
        }
      }

      function ensureFpedData(subject) {
        if (!subject || subject.id !== "fped") return;
        const data = window.FPED_CONTENT || {};
        if (!subject.capitole?.length) {
          subject.capitole = data.capitole || [];
        }
        if (!subject.topics?.length) {
          subject.topics = (window.FPED_QUIZ || []).map((q) => ({
            id: q.id,
            title: q.title,
            question: q.questions?.[0] || null,
            questions: q.questions || [],
          }));
        }
      }

      function ensurePhedData(subject) {
        if (!subject || subject.id !== "phed") return;
        const data = window.PHED_CONTENT || {};
        if (!subject.capitole?.length) {
          subject.capitole = data.capitole || [];
        }
        if (!subject.topics?.length) {
          subject.topics = (window.PHED_QUIZ || []).map((q) => ({
            id: q.id,
            title: q.title,
            // păstrează primul item pentru compatibilitate, dar expune și lista completă
            question: q.questions?.[0] || null,
            questions: q.questions || [],
          }));
        }
      }

      function rerenderSubjectCapitolePreserveState(subject) {
        if (!subject || !subject.capitole?.length) return;
        const openCapitole = new Set(
          Array.from(
            capitoleContainer.querySelectorAll(".subcap-list.expanded")
          ).map((el) => el.id?.replace("-subs", ""))
        );
        const openSubcaps = new Set(
          Array.from(
            capitoleContainer.querySelectorAll(".subcap-quiz-list.expanded")
          ).map((el) => el.dataset.quizList)
        );
        const openDecks = new Set(
          Array.from(
            capitoleContainer.querySelectorAll(".deck-collapsible.expanded")
          ).map((el) => el.dataset.deckList)
        );
        renderCapitole(subject);
        // re-open previous states
        capitoleContainer.querySelectorAll(".subcap-list").forEach((el) => {
          const id = el.id?.replace("-subs", "");
          if (id && openCapitole.has(id)) {
            el.classList.add("expanded");
            const btn = capitoleContainer.querySelector(
              `[data-toggle='${id}']`
            );
            if (btn) setChevron(btn, true);
          }
        });
        capitoleContainer
          .querySelectorAll(".subcap-quiz-list")
          .forEach((el) => {
            const id = el.dataset.quizList;
            if (id && openSubcaps.has(id)) {
              el.classList.add("expanded");
              const btn = el.previousElementSibling;
              if (btn?.classList.contains("toggle-btn")) setChevron(btn, true);
              if (el.dataset.quizIds) {
                const ids = el.dataset.quizIds.split(",").filter(Boolean);
                el.innerHTML = renderInlineQuizList(subject, ids);
                wireInlineQuizButtons(el, subject);
              }
            }
          });
        capitoleContainer
          .querySelectorAll(".deck-collapsible")
          .forEach((el) => {
            const id = el.dataset.deckList;
            if (id && openDecks.has(id)) {
              el.classList.add("expanded");
              const btn = capitoleContainer.querySelector(
                `[data-deck-toggle='${id}']`
              );
              if (btn) setChevron(btn, true);
            }
          });
      }

      function shuffleIndices(len) {
        const arr = Array.from({ length: len }, (_, i) => i);
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function launchConfetti() {
        const container = detailOverlay.querySelector(".modal");
        if (!container) return;
        for (let i = 0; i < 16; i++) {
          const c = document.createElement("div");
          c.className = "confetti";
          c.style.left = `${Math.random() * 100}%`;
          c.style.background = i % 2 ? "#ffb703" : "#6be8f7";
          c.style.animationDelay = `${Math.random() * 0.2}s`;
          container.appendChild(c);
          setTimeout(() => c.remove(), 1000);
        }
      }

      function addEmojiPop(targetEl) {
        if (!targetEl) return;
        const rect = targetEl.getBoundingClientRect();
        const containerRect = detailOverlay.getBoundingClientRect();
        const emoji = document.createElement("div");
        emoji.className = "emoji-pop";
        emoji.textContent = "🎉";
        emoji.style.left = `${Math.min(
          rect.left + rect.width / 2 - containerRect.left,
          containerRect.width - 24
        )}px`;
        emoji.style.top = `${rect.top - containerRect.top - 10}px`;
        detailOverlay.appendChild(emoji);
        setTimeout(() => emoji.remove(), 900);
      }

      function highlightCompletedTopic(listEl, topicId) {
        if (!listEl || !topicId) return;
        const item = listEl.querySelector(
          `[data-topic-container='${topicId}']`
        );
        if (!item) return;
        item.classList.add("completed-highlight");
        setTimeout(() => item.classList.remove("completed-highlight"), 900);
      }

      function openQuiz(subject, topic, sourceListEl) {
        currentTopic = topic;
        currentSubject = subject;
        currentQuizListEl = sourceListEl || null;
        if (!topic || !(topic.question || topic.questions)) return;
        const questions =
          topic.questions || (topic.question ? [topic.question] : []);
        currentQuestions = questions;
        quizPanelTitle.textContent = `${topic.title}`;
        quizPanelContent.innerHTML = questions
          .map((q, qIdx) => {
            const isMulti = Array.isArray(q.answer);
            const inputType = isMulti ? "checkbox" : "radio";
            const order = shuffleIndices(q.options.length);
            const optionsHtml = order
              .map(
                (idx) => `
                <label class="choice">
                  <input type="${inputType}" name="q-${qIdx}" value="${idx}"> ${q.options[idx]}
                </label>
              `
              )
              .join("");
            return `
              <div class="quiz-question" data-q="${qIdx}">
                <h4>${q.text}</h4>
                ${optionsHtml}
              </div>
            `;
          })
          .join('<hr class="quiz-sep">');
        wireTooltips(quizPanelContent);
        quizPanelContent.scrollTop = 0;
        const modalEl = detailOverlay.querySelector(".modal");
        if (modalEl) modalEl.scrollTo({ top: 0, behavior: "auto" });
        quizPanelFeedback.className = "feedback info";
        quizPanelFeedback.textContent =
          "Răspunde la toate întrebările și trimite pentru validare.";
        quizPanel.classList.remove("hidden", "exit", "complete");
        requestAnimationFrame(() => quizPanel.classList.add("show"));
        quizPanelSubmit.classList.remove("hidden");
        quizPanelRestart.classList.add("hidden");
        quizPanelBack.classList.remove("hidden");
        quizPanelBack.textContent = "← Înapoi";
        quizPanelBack.classList.remove("split", "primary");
        quizPanelBack.classList.add("secondary");
        quizPanelRestart.classList.remove("split", "primary");
        quizPanelRestart.classList.add("secondary");
        quizCompleted = false;
        capitoleContainer.classList.add("hidden");
        topicsContainer.classList.add("hidden");
        pdfLink.classList.add("hidden");
        backToList.classList.remove("hidden");
      }

      function submitQuizAnswer() {
        if (!currentTopic || !currentQuestions.length) return;
        let answeredAll = true;
        let correctCount = 0;

        // clear previous state
        quizPanelContent.querySelectorAll(".choice").forEach((c) => {
          c.classList.remove("correct", "incorrect");
        });
        quizPanelContent.querySelectorAll(".quiz-question").forEach((q) => {
          q.classList.remove("q-correct", "q-incorrect");
        });

        currentQuestions.forEach((q, idx) => {
          const inputs = Array.from(
            quizPanelContent.querySelectorAll(`input[name='q-${idx}']:checked`)
          );
          const isMulti = Array.isArray(q.answer);
          if (!inputs.length) {
            answeredAll = false;
            return;
          }
          let isCorrect = false;
          if (isMulti) {
            const answerSet = new Set(q.answer);
            const selectedVals = inputs.map((i) => Number(i.value));
            const hasAll = selectedVals.every((v) => answerSet.has(v));
            const noExtras = selectedVals.length === answerSet.size;
            isCorrect = hasAll && noExtras;
            inputs.forEach((inp) => {
              const label = inp.closest(".choice");
              if (!label) return;
              label.classList.add(
                answerSet.has(Number(inp.value)) ? "correct" : "incorrect"
              );
            });
          } else {
            const selected = inputs[0];
            const val = Number(selected.value);
            isCorrect = val === q.answer;
            const label = selected.closest(".choice");
            if (label) {
              label.classList.add(isCorrect ? "correct" : "incorrect");
            }
          }
          if (isCorrect) correctCount += 1;
          const questionWrapper = inputs[0]?.closest(".quiz-question");
          if (questionWrapper) {
            questionWrapper.classList.add(
              isCorrect ? "q-correct" : "q-incorrect"
            );
          }
        });

        if (!answeredAll) {
          quizPanelFeedback.className = "feedback info";
          quizPanelFeedback.textContent =
            "Completează toate întrebările înainte de a trimite.";
          quizPanelFeedback.style.display = "block";
          return;
        }

        const allCorrect = correctCount === currentQuestions.length;
        const newVal = allCorrect ? 100 : 50;
        setTopicProgress(currentTopic.id, newVal);

        quizPanelFeedback.className = allCorrect
          ? "feedback success"
          : "feedback info";
        quizPanelFeedback.textContent = allCorrect
          ? `Perfect! ${correctCount}/${currentQuestions.length} corecte.`
          : `${correctCount}/${currentQuestions.length} corecte. Corectează răspunsurile marcate și retrimite.`;
        quizPanelFeedback.style.display = "block";

        if (allCorrect) {
          quizPanelSubmit.classList.add("hidden");
          quizPanelRestart.classList.remove("hidden");
          quizPanelBack.classList.remove("hidden");
          quizPanelBack.textContent = "Întoarce-te la QUIZuri";
          quizPanelRestart.textContent = "Reia QUIZul";
          quizPanelBack.classList.add("split");
          quizPanelRestart.classList.add("split");
          quizPanelBack.classList.remove("secondary");
          quizPanelBack.classList.add("primary");
          quizPanelRestart.classList.remove("primary");
          quizPanelRestart.classList.add("secondary");
          quizCompleted = true;
          lastCompletedTopicId = currentTopic?.id || null;
        } else {
          quizPanelSubmit.classList.remove("hidden");
          quizPanelRestart.classList.add("hidden");
          quizPanelBack.classList.remove("hidden");
          quizPanelBack.textContent = "← Înapoi";
          quizPanelBack.classList.remove("split");
          quizPanelRestart.classList.remove("split");
          quizPanelBack.classList.remove("primary");
          quizPanelBack.classList.add("secondary");
          quizCompleted = false;
          lastCompletedTopicId = null;
        }
      }

      function restartQuiz() {
        if (currentSubject && currentTopic) {
          openQuiz(currentSubject, currentTopic, currentQuizListEl);
        }
      }

      function goBackToSubcap() {
        if (quizCompleted) {
          quizPanel.classList.remove("show");
          quizPanel.classList.add("complete");
          launchConfetti();
          setTimeout(() => {
            quizPanel.classList.add("hidden");
            quizPanel.classList.remove("complete", "show", "exit");
            syncDeckHeights(capitoleContainer);
          }, 300);
        } else {
          quizPanel.classList.remove("show");
          quizPanel.classList.add("exit");
          setTimeout(() => {
            quizPanel.classList.add("hidden");
            quizPanel.classList.remove("exit", "show", "complete");
            syncDeckHeights(capitoleContainer);
          }, 220);
        }
        quizPanelContent.innerHTML = "";
        quizPanelFeedback.textContent = "";
        quizPanelSubmit.classList.remove("hidden");
        quizPanelRestart.classList.add("hidden");
        quizPanelBack.classList.remove("hidden");
        quizPanelBack.textContent = "← Înapoi";
        quizPanelBack.classList.remove("split");
        quizPanelRestart.classList.remove("split");
        quizPanelBack.classList.remove("primary");
        quizPanelBack.classList.add("secondary");
        const lastTopicId = currentTopic
          ? currentTopic.id
          : lastCompletedTopicId;
        currentQuestions = [];
        currentTopic = null;
        pdfLink.classList.remove("hidden");
        backToList.classList.add("hidden");
        // keep subcap/quiz list open
        let workingQuizList = currentQuizListEl;
        if (currentQuizListEl) {
          const subcapId = currentQuizListEl.dataset.quizList;
          const refreshed =
            subcapId &&
            capitoleContainer.querySelector(`[data-quiz-list='${subcapId}']`);
          workingQuizList = refreshed || currentQuizListEl;
          workingQuizList.classList.add("expanded");
          const toggleBtn = workingQuizList.previousElementSibling;
          if (toggleBtn) setChevron(toggleBtn, true);
          const ancestorCollapsible = workingQuizList.closest(".collapsible");
          if (ancestorCollapsible)
            ancestorCollapsible.classList.add("expanded");
          if (refreshed && refreshed.dataset.quizIds) {
            const ids = refreshed.dataset.quizIds.split(",").filter(Boolean);
            refreshed.innerHTML = renderInlineQuizList(currentSubject, ids);
            wireInlineQuizButtons(refreshed, currentSubject);
          }
        }

        if (
          currentSubject &&
          currentSubject.capitole &&
          currentSubject.capitole.length
        ) {
          capitoleContainer.classList.remove("hidden");
          if (quizCompleted && workingQuizList) {
            const topicId = lastCompletedTopicId;
            const targetItem =
              workingQuizList.querySelector(
                `[data-topic-container='${topicId}']`
              ) || workingQuizList;
            targetItem.scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
            setTimeout(() => {
              highlightCompletedTopic(workingQuizList, topicId);
              const item =
                workingQuizList.querySelector(
                  `[data-topic-container='${topicId}']`
                ) || workingQuizList;
              item.classList.add("completed-highlight");
              setTimeout(
                () => item.classList.remove("completed-highlight"),
                1900
              );
              addEmojiPop(item);
              updateBarWidths(workingQuizList, true, topicId);
            }, 320);
          } else if (lastTopicId && workingQuizList) {
            const targetItem =
              workingQuizList.querySelector(
                `[data-topic-container='${lastTopicId}']`
              ) || workingQuizList;
            targetItem.scrollIntoView({ behavior: "smooth", block: "center" });
          }
        } else {
          topicsContainer.classList.remove("hidden");
          capitoleContainer.classList.add("hidden");
          renderTopics(currentSubject);
          if (quizCompleted && lastTopicId) {
            updateBarWidths(topicsContainer, true, lastTopicId);
          }
          if (lastTopicId) {
            const targetBtn = topicsContainer.querySelector(
              `[data-topic='${lastTopicId}']`
            );
            const targetItem = targetBtn ? targetBtn.closest(".topic") : null;
            (targetItem || targetBtn || topicsContainer).scrollIntoView({
              behavior: "smooth",
              block: "center",
            });
          }
        }
      }

      document.addEventListener("keydown", (e) => {
        if (e.key !== "Escape") return;
        if (detailOverlay.classList.contains("show")) {
          closeModal(true);
        }
      });

      document.addEventListener("keydown", (e) => {
        if (e.shiftKey && (e.key === "q" || e.key === "Q")) {
          e.preventDefault();
          if (detailOverlay.classList.contains("show") && currentSubject) {
            resetSubject(currentSubject);
          } else {
            resetAllProgress();
          }
        }
      });

      document.addEventListener("keydown", (e) => {
        if (e.shiftKey && (e.key === "p" || e.key === "P")) {
          e.preventDefault();
          if (detailOverlay.classList.contains("show") && currentSubject) {
            completeSubject(currentSubject);
          }
        }
      });
    </script>
  </body>
</html>
